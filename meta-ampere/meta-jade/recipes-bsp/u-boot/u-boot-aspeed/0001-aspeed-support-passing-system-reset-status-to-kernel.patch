From fb27f51ab45097ba26cc066a49a330f67adf8b32 Mon Sep 17 00:00:00 2001
From: "Thang Q. Nguyen" <thang@os.amperecomputing.com>
Date: Thu, 2 Dec 2021 09:57:18 +0000
Subject: [PATCH] aspeed: support passing system reset status to kernel via
 bootargs

This is a backport of the patch file from
openbmc/meta-yadro/meta-nicole/recipes-bsp/u-boot/
to add the Aspeed reset reason to bootargs so kernel applications
can query it.

Tested: /proc/cmdline must contain:
  - resetreason=power after cold bmc boot
  - resetreason=watchdog after warm bmc reboot

Signed-off-by: Thang Q. Nguyen <thang@os.amperecomputing.com>
---
 board/aspeed/ast-g5/ast-g5.c | 89 ++++++++++++++++++++++++++++++++++++
 include/configs/ast-g5-phy.h |  2 +
 2 files changed, 91 insertions(+)

diff --git a/board/aspeed/ast-g5/ast-g5.c b/board/aspeed/ast-g5/ast-g5.c
index e67a4bf8b2..17e9470076 100644
--- a/board/aspeed/ast-g5/ast-g5.c
+++ b/board/aspeed/ast-g5/ast-g5.c
@@ -8,6 +8,8 @@
  */
 
 #include <common.h>
+#include <stdlib.h>
+#include <asm/arch/regs-scu.h>
 #include <netdev.h>
 
 #include <asm/arch/ast_scu.h>
@@ -24,6 +26,93 @@ int board_init(void)
 	return 0;
 }
 
+#ifdef CONFIG_BOARD_LATE_INIT
+static void update_bootargs_cmd(const char *key, const char *value)
+{
+	int buf_len;
+	char *buf;
+	char *cmdline;
+	char *end = NULL;
+
+	if (!key || (key[0] == '\0')) {
+		printf("%s: Empty key not allowed\n", __func__);
+		return;
+	}
+
+	cmdline = getenv("bootargs");
+
+	/* Allocate space for maximum possible new command line */
+	buf_len = (cmdline ? strlen(cmdline) : 0)
+		+ 1 /* spacebar as delimiter */
+		+ strlen(key)
+		+ (value ? 1 /* equal sign */ + strlen(value) : 0)
+		+ 1 /* terminating null */;
+
+	buf = calloc(buf_len, sizeof(char));
+	if (!buf) {
+		printf("%s: out of memory\n", __func__);
+		return;
+	}
+
+	if (cmdline)
+	{
+		char *start = strstr(cmdline, key);
+
+		/* Check for full word match. Match should be start of cmdline
+		 * or there should be space before match
+		 **/
+		if (start && ((start == cmdline) || (*(start - 1) == ' '))) {
+			strncat(buf, cmdline, (start - cmdline));
+
+			/* Find the end of the keyword[=value] pair,
+			 * including a single training space character, if any.
+			 * Skip the found substring, mark the tail of cmdline.
+			 **/
+			end = strchr(start, ' ');
+			if (end) {
+				end++;
+			}
+		} else {
+			strcat(buf, cmdline);
+			strcat(buf, " ");
+		}
+	}
+
+	strcat(buf, key);
+	if (value) {
+		strcat(buf, "=");
+		strcat(buf, value);
+	}
+
+	if (end) {
+		strcat(buf, " ");
+		strcat(buf, end);
+	}
+
+	setenv("bootargs", buf);
+	free(buf);
+}
+
+int board_late_init(void)
+{
+	u32 rest = readl(AST_SCU_BASE + AST_SCU_SYS_CTRL);
+
+	if (rest & SCU_SYS_EXT_RESET_FLAG) {
+		update_bootargs_cmd("resetreason", "external");
+	} else if (rest & SCU_SYS_WDT_RESET_FLAG) {
+		update_bootargs_cmd("resetreason", "watchdog");
+	} else if (rest & SCU_SYS_PWR_RESET_FLAG) {
+		update_bootargs_cmd("resetreason", "power");
+	} else {
+		char value[32];
+		snprintf(value, sizeof(value) - 1, "0x%x", rest);
+		update_bootargs_cmd("resetreason", value);
+	}
+
+	return 0;
+}
+#endif /* CONFIG_BOARD_LATE_INIT */
+
 int dram_init(void)
 {
 	u32 vga = ast_scu_get_vga_memsize();
diff --git a/include/configs/ast-g5-phy.h b/include/configs/ast-g5-phy.h
index 62ddb841e5..1f433cc761 100644
--- a/include/configs/ast-g5-phy.h
+++ b/include/configs/ast-g5-phy.h
@@ -30,4 +30,6 @@
 /* platform.S */
 #define	CONFIG_DRAM_ECC_SIZE		0x10000000
 
+/* Call board_late_init */
+#define CONFIG_BOARD_LATE_INIT		1
 #endif	/* __AST_G5_PHY_CONFIG_H */
-- 
2.25.1

