From c4eef3ecf8dacb6e56e4b50912f7b5862199bccd Mon Sep 17 00:00:00 2001
From: Chau Ly <chaul@amperecomputing.com>
Date: Tue, 1 Nov 2022 10:54:20 +0700
Subject: [PATCH 6/6] Support IntrusionSensor patch and IntrusionSensorReArm

This patch adds patch handler for "Intrusionsensor" and supports
"IntrusionSensorReArm" property under "PhysicalSecurity". The
"IntrusionSensorReArm" property is updated following the "ReArm"
property under xyz.openbmc_project.Chassis.Intrusion interface on
Dbus.
Patch handler for "Intrusionsensor" will update the "Status" property
under xyz.openbmc_project.Chassis.Intrusion interface on Dbus to "Normal"
as a reset event. In "Manual" ReArm mode, this allows the "Status" property
to be updated normally again after an intrusion event .

Signed-off-by: Chau Ly <chaul@amperecomputing.com>
---
 redfish-core/lib/chassis.hpp | 58 +++++++++++++++++++++++++++++++++---
 1 file changed, 54 insertions(+), 4 deletions(-)

diff --git a/redfish-core/lib/chassis.hpp b/redfish-core/lib/chassis.hpp
index 54893516..aa3f8765 100644
--- a/redfish-core/lib/chassis.hpp
+++ b/redfish-core/lib/chassis.hpp
@@ -105,6 +105,29 @@ inline void getIntrusionByService(std::shared_ptr<bmcweb::AsyncResp> aResp,
         });
 }
 
+inline void getIntrusionReArmByService(std::shared_ptr<bmcweb::AsyncResp> aResp,
+                                  const std::string& service,
+                                  const std::string& objPath)
+{
+    BMCWEB_LOG_DEBUG << "Get intrusion rearm by service \n";
+
+    sdbusplus::asio::getProperty<std::string>(
+        *crow::connections::systemBus, service, objPath,
+        "xyz.openbmc_project.Chassis.Intrusion", "ReArm",
+        [aResp{std::move(aResp)}](const boost::system::error_code ec,
+                                  const std::string& value) {
+        if (ec)
+        {
+            // do not add err msg in redfish response, because this is not
+            //     mandatory property
+            BMCWEB_LOG_ERROR << "DBUS response error " << ec << "\n";
+            return;
+        }
+
+        aResp->res.jsonValue["PhysicalSecurity"]["IntrusionSensorReArm"] = value;
+    });
+}
+
 /**
  * Retrieves physical security properties over dbus
  */
@@ -113,7 +136,7 @@ inline void getPhysicalSecurityData(std::shared_ptr<bmcweb::AsyncResp> aResp)
     constexpr std::array<std::string_view, 1> interfaces = {
         "xyz.openbmc_project.Chassis.Intrusion"};
     dbus::utility::getSubTree(
-        "/xyz/openbmc_project/Intrusion", 1, interfaces,
+        "/xyz/openbmc_project/", 0, interfaces,
         [aResp{std::move(aResp)}](
             const boost::system::error_code& ec,
             const dbus::utility::MapperGetSubTreeResponse& subtree) {
@@ -130,6 +153,7 @@ inline void getPhysicalSecurityData(std::shared_ptr<bmcweb::AsyncResp> aResp)
             for (const auto& service : object.second)
             {
                 getIntrusionByService(aResp, service.first, object.first);
+                getIntrusionReArmByService(aResp, service.first, object.first);
                 return;
             }
         }
@@ -470,12 +494,40 @@ inline void
     }
     std::optional<bool> locationIndicatorActive;
     std::optional<std::string> indicatorLed;
+    std::optional<std::string> intrusionSensor;
 
     if (param.empty())
     {
         return;
     }
 
+    const std::string& chassisId = param;
+
+    if (!json_util::readJsonPatch(
+            req, asyncResp->res, "PhysicalSecurity/IntrusionSensor",
+            intrusionSensor))
+    {
+        return;
+    }
+
+    if (intrusionSensor && (intrusionSensor.value() == "Normal"))
+    {
+        crow::connections::systemBus->async_method_call(
+            [asyncResp, chassisId, intrusionSensor](const boost::system::error_code ec) {
+            if (ec)
+            {
+                messages::internalError(asyncResp->res);
+                return;
+            }
+            messages::success(asyncResp->res);
+            },
+            "xyz.openbmc_project.IntrusionSensor",
+            "/xyz/openbmc_project/Chassis/Intrusion",
+            "org.freedesktop.DBus.Properties", "Set",
+            "xyz.openbmc_project.Chassis.Intrusion", "Status",
+            dbus::utility::DbusVariantType(*intrusionSensor));
+    }
+
     if (!json_util::readJsonPatch(
             req, asyncResp->res, "LocationIndicatorActive",
             locationIndicatorActive, "IndicatorLED", indicatorLed))
@@ -486,7 +538,7 @@ inline void
     // TODO (Gunnar): Remove IndicatorLED after enough time has passed
     if (!locationIndicatorActive && !indicatorLed)
     {
-        return; // delete this when we support more patch properties
+        //return; // delete this when we support more patch properties
     }
     if (indicatorLed)
     {
@@ -499,8 +551,6 @@ inline void
         "xyz.openbmc_project.Inventory.Item.Board",
         "xyz.openbmc_project.Inventory.Item.Chassis"};
 
-    const std::string& chassisId = param;
-
     dbus::utility::getSubTree(
         "/xyz/openbmc_project/inventory", 0, interfaces,
         [asyncResp, chassisId, locationIndicatorActive,
-- 
2.25.1

