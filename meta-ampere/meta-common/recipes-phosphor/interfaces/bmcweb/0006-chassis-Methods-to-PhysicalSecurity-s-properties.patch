From 8dea4416299fcffcef49607086f7e79ad93d1919 Mon Sep 17 00:00:00 2001
From: Chau Ly <chaul@amperecomputing.com>
Date: Wed, 19 Jul 2023 08:42:18 +0000
Subject: [PATCH 06/12] chassis: Methods to PhysicalSecurity's properties

This commit handles getting method to IntrusionSensorReArm property
under PhysicalSecurity. Moreover, Redfish Data Model Specification says
about IntrusionSensor that "If the IntrusionSensorReArm property
contains Manual, a client may set this property to Normal to reset the
physical security state". This will handle patching to IntrusionSensor
under PhysicalSecurity.

This also deprecated IntrusionSensorNumber property as Redfish schema
v1.22 specified "IntrusionSensorNumber has been deprecated in order to
allow for multiple physical sensors to construct this object". Moreover,
it was previously hardcoded to 1, so it didn't cause any effect then.

Tested: On Ampere Mt.Mitchell using dbus-sensors intrusionsensor with
Aspeed2600_Hwmon method, rearm mode is Manual.

- Normal situation:

$ curl -X GET -u root:0penBmc --insecure \
     https://${BMC_IP}/redfish/v1/Chassis/chassis

...
"PhysicalSecurity": {
    "IntrusionSensor": "Normal",
    "IntrusionSensorReArm": "Manual"
},
...

- Chassis intrusion detected, the above result will be:

"PhysicalSecurity": {
    "IntrusionSensor": "HardwareIntrusion",
    "IntrusionSensorReArm": "Manual"
}

- Manually rearm the sensor:

$ curl -X PATCH --user root:0penBmc -H \
"Content-Type: application/json" --insecure \
https://${BMC_IP}/redfish/v1/Chassis/chassis -d \
'{ "PhysicalSecurity": { "IntrusionSensor": "Normal"} }'

{
  "@Message.ExtendedInfo": [
    {
      "@odata.type": "#Message.v1_1_1.Message",
      "Message": "The request completed successfully.",
      "MessageArgs": [],
      "MessageId": "Base.1.16.0.Success",
      "MessageSeverity": "OK",
      "Resolution": "None"
    }
  ]
}

The result will be as in normal situation.

Change-Id: If50332a1e55f2bafcf395e0d313b7d58b35c55cd
Signed-off-by: Chau Ly <chaul@amperecomputing.com>
---
 redfish-core/lib/chassis.hpp | 242 +++++++++++++++++++++++++++++------
 1 file changed, 202 insertions(+), 40 deletions(-)

diff --git a/redfish-core/lib/chassis.hpp b/redfish-core/lib/chassis.hpp
index 397e31cc..1b2f1187 100644
--- a/redfish-core/lib/chassis.hpp
+++ b/redfish-core/lib/chassis.hpp
@@ -19,6 +19,7 @@
 
 #include "app.hpp"
 #include "dbus_utility.hpp"
+#include "generated/enums/chassis.hpp"
 #include "health.hpp"
 #include "led.hpp"
 #include "query.hpp"
@@ -34,10 +35,121 @@
 #include <sdbusplus/unpack_properties.hpp>
 
 #include <array>
+#include <memory>
+#include <string>
 #include <string_view>
 
 namespace redfish
 {
+/**
+ * @brief Convert chassis intrusion sensor status string on DBus to Redfish
+ *
+ * @param[in] status - Status property string on DBus.
+ *
+ * @return An optional of chassis::IntrusionSensor enum.
+ */
+inline std::optional<chassis::IntrusionSensor>
+    dbusChassisIntrusionStatusToRf(std::string_view status)
+{
+    if (status == "xyz.openbmc_project.Chassis.Intrusion.Status.Normal")
+    {
+        return chassis::IntrusionSensor::Normal;
+    }
+    if (status ==
+        "xyz.openbmc_project.Chassis.Intrusion.Status.HardwareIntrusion")
+    {
+        return chassis::IntrusionSensor::HardwareIntrusion;
+    }
+    if (status ==
+        "xyz.openbmc_project.Chassis.Intrusion.Status.TamperingDetected")
+    {
+        return chassis::IntrusionSensor::TamperingDetected;
+    }
+    if (status == "xyz.openbmc_project.Chassis.Intrusion.Status.Unknown")
+    {
+        return std::nullopt;
+    }
+    return chassis::IntrusionSensor::Invalid;
+}
+
+/**
+ * @brief Convert chassis intrusion sensor rearm mode string on DBus to Redfish
+ *
+ * @param[in] rearmMode - Rearm property string on DBus.
+ *
+ * @return An optional of chassis::IntrusionSensorReArm enum.
+ */
+inline std::optional<chassis::IntrusionSensorReArm>
+    dbusChassisIntrusionRearmModeToRf(std::string_view rearmMode)
+{
+    if (rearmMode == "xyz.openbmc_project.Chassis.Intrusion.RearmMode.Manual")
+    {
+        return chassis::IntrusionSensorReArm::Manual;
+    }
+    if (rearmMode ==
+        "xyz.openbmc_project.Chassis.Intrusion.RearmMode.Automatic")
+    {
+        return chassis::IntrusionSensorReArm::Automatic;
+    }
+    return chassis::IntrusionSensorReArm::Invalid;
+}
+
+/**
+ * @brief Fill PhysicalSecurity's data
+ *
+ * @param[in] resp - HTTP response.
+ * @param[in] propertiesMap - The property map under
+ *            "xyz.openbmc_project.Chassis.Intrusion" interface.
+ *
+ * @return None.
+ */
+inline void fillPhysicalSecurityData(
+    crow::Response& resp, const dbus::utility::DBusPropertiesMap& propertiesMap)
+{
+    std::string status;
+    std::string rearmMode;
+
+    const bool success = sdbusplus::unpackPropertiesNoThrow(
+        dbus_utils::UnpackErrorPrinter(), propertiesMap, "Status", status,
+        "Rearm", rearmMode);
+
+    if (!success)
+    {
+        messages::internalError(resp);
+        return;
+    }
+
+    std::optional<chassis::IntrusionSensor> intrusionSensor =
+        dbusChassisIntrusionStatusToRf(status);
+
+    if (!intrusionSensor)
+    {
+        BMCWEB_LOG_WARNING("Unknown ChassisIntrusionStatus: {}", status);
+    }
+    else
+    {
+        if (*intrusionSensor == chassis::IntrusionSensor::Invalid)
+        {
+            BMCWEB_LOG_ERROR("Invalid ChassisIntrusionStatus: {}", status);
+            messages::internalError(resp);
+            return;
+        }
+        resp.jsonValue["PhysicalSecurity"]["IntrusionSensor"] =
+            *intrusionSensor;
+    }
+
+    std::optional<chassis::IntrusionSensorReArm> intrusionSensorReArm =
+        dbusChassisIntrusionRearmModeToRf(rearmMode);
+
+    if (*intrusionSensorReArm == chassis::IntrusionSensorReArm::Invalid)
+    {
+        BMCWEB_LOG_ERROR("Invalid ChassisIntrusionRearmMode: {}", rearmMode);
+        messages::internalError(resp);
+        return;
+    }
+    resp.jsonValue["PhysicalSecurity"]["IntrusionSensorReArm"] =
+        *intrusionSensorReArm;
+}
 
 /**
  * @brief Retrieves resources over dbus to link to the chassis
@@ -133,61 +245,52 @@ inline void getChassisState(std::shared_ptr<bmcweb::AsyncResp> asyncResp)
         });
 }
 
-inline void getIntrusionByService(std::shared_ptr<bmcweb::AsyncResp> asyncResp,
-                                  const std::string& service,
-                                  const std::string& objPath)
-{
-    BMCWEB_LOG_DEBUG("Get intrusion status by service ");
-
-    sdbusplus::asio::getProperty<std::string>(
-        *crow::connections::systemBus, service, objPath,
-        "xyz.openbmc_project.Chassis.Intrusion", "Status",
-        [asyncResp{std::move(asyncResp)}](const boost::system::error_code& ec,
-                                          const std::string& value) {
-        if (ec)
-        {
-            // do not add err msg in redfish response, because this is not
-            //     mandatory property
-            BMCWEB_LOG_ERROR("DBUS response error {}", ec);
-            return;
-        }
-
-        asyncResp->res.jsonValue["PhysicalSecurity"]["IntrusionSensorNumber"] =
-            1;
-        asyncResp->res.jsonValue["PhysicalSecurity"]["IntrusionSensor"] = value;
-        });
-}
-
 /**
  * Retrieves physical security properties over dbus
  */
 inline void
-    getPhysicalSecurityData(std::shared_ptr<bmcweb::AsyncResp> asyncResp)
+    getPhysicalSecurityData(const std::shared_ptr<bmcweb::AsyncResp>& asyncResp)
 {
     constexpr std::array<std::string_view, 1> interfaces = {
         "xyz.openbmc_project.Chassis.Intrusion"};
     dbus::utility::getSubTree(
         "/xyz/openbmc_project", 0, interfaces,
-        [asyncResp{std::move(asyncResp)}](
-            const boost::system::error_code& ec,
-            const dbus::utility::MapperGetSubTreeResponse& subtree) {
-        if (ec)
+        [asyncResp](const boost::system::error_code& ec,
+                    const dbus::utility::MapperGetSubTreeResponse& subtree) {
+        if (ec || subtree.empty())
         {
-            // do not add err msg in redfish response, because this is not
-            //     mandatory property
-            BMCWEB_LOG_INFO("DBUS error: no matched iface {}", ec);
+            BMCWEB_LOG_WARNING("DBUS error: no matched iface");
             return;
         }
-        // Iterate over all retrieved ObjectPaths.
-        for (const auto& object : subtree)
+
+        // Process the first subtree response only
+        // assuming there's only one place implementing this interface
+        const auto& [objPath, serviceMap] = subtree[0];
+
+        if (serviceMap.empty())
         {
-            if (!object.second.empty())
+            return;
+        }
+
+        const std::string& service = serviceMap.front().first;
+
+        sdbusplus::asio::getAllProperties(
+            *crow::connections::systemBus, service, objPath,
+            "xyz.openbmc_project.Chassis.Intrusion",
+            [asyncResp](const boost::system::error_code& ec1,
+                        const dbus::utility::DBusPropertiesMap& propertiesMap) {
+            if (ec1)
             {
-                const auto service = object.second.front();
-                getIntrusionByService(asyncResp, service.first, object.first);
+                if (ec1.value() != EBADR)
+                {
+                    BMCWEB_LOG_WARNING("DBUS response error for Properties{}",
+                                       ec1);
+                }
                 return;
             }
-        }
+
+            fillPhysicalSecurityData(asyncResp->res, propertiesMap);
+            });
         });
 }
 
@@ -643,6 +746,25 @@ inline void
     getPhysicalSecurityData(asyncResp);
 }
 
+inline void setIntrusionSensorByService(
+    const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
+    const std::string& service, const std::string& objPath,
+    const std::string& intrusionSensor)
+{
+    sdbusplus::asio::setProperty(
+        *crow::connections::systemBus, service, objPath,
+        "xyz.openbmc_project.Chassis.Intrusion", "Status", intrusionSensor,
+        [asyncResp](const boost::system::error_code& ec) {
+        if (ec)
+        {
+            BMCWEB_LOG_ERROR("DBUS error: failed to set property");
+            messages::internalError(asyncResp->res);
+            return;
+        }
+        messages::success(asyncResp->res);
+        });
+}
+
 inline void
     handleChassisPatch(App& app, const crow::Request& req,
                        const std::shared_ptr<bmcweb::AsyncResp>& asyncResp,
@@ -654,6 +776,7 @@ inline void
     }
     std::optional<bool> locationIndicatorActive;
     std::optional<std::string> indicatorLed;
+    std::optional<std::string> intrusionSensor;
 
     if (param.empty())
     {
@@ -662,11 +785,50 @@ inline void
 
     if (!json_util::readJsonPatch(
             req, asyncResp->res, "LocationIndicatorActive",
-            locationIndicatorActive, "IndicatorLED", indicatorLed))
+            locationIndicatorActive, "IndicatorLED", indicatorLed,
+            "PhysicalSecurity/IntrusionSensor", intrusionSensor))
     {
         return;
     }
 
+    if (intrusionSensor)
+    {
+        if (*intrusionSensor != "Normal")
+        {
+            BMCWEB_LOG_ERROR(
+                "IntrusionSensor property only accepts Normal to reset the physical security state");
+            messages::propertyValueIncorrect(asyncResp->res, "IntrusionSensor",
+                                             *intrusionSensor);
+            return;
+        }
+        constexpr std::array<std::string_view, 1> interfaces = {
+            "xyz.openbmc_project.Chassis.Intrusion"};
+        dbus::utility::getSubTree(
+            "/xyz/openbmc_project", 0, interfaces,
+            [asyncResp, intrusionSensor](
+                const boost::system::error_code& ec,
+                const dbus::utility::MapperGetSubTreeResponse& subtree) {
+            if (ec || subtree.empty())
+            {
+                BMCWEB_LOG_ERROR("DBUS error: no matched iface");
+                messages::internalError(asyncResp->res);
+                return;
+            }
+
+            // Process the first subtree response only
+            // assuming there's only one place implementing this interface
+            const auto& [objPath, serviceMap] = subtree[0];
+
+            if (!serviceMap.empty())
+            {
+                const std::string& service = serviceMap.front().first;
+                setIntrusionSensorByService(
+                    asyncResp, service, objPath,
+                    "xyz.openbmc_project.Chassis.Intrusion.Status.Normal");
+            }
+            });
+    }
+
     // TODO (Gunnar): Remove IndicatorLED after enough time has passed
     if (!locationIndicatorActive && !indicatorLed)
     {
-- 
2.25.1

