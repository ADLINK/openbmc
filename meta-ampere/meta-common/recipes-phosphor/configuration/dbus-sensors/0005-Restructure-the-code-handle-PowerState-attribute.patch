From f27ec1316e59dab924ac5ad3b31cdb7ec25945d3 Mon Sep 17 00:00:00 2001
From: ThuBaNguyen <thu@os.amperecomputing.com>
Date: Wed, 15 Jun 2022 14:10:35 +0000
Subject: [PATCH 5/5] Restructure the code handle PowerState attribute

There are some below issues with the code handle PowerState attribute:
1. Use difference properties to the "PowerState" configuration.
    + If the PowerState is "On" the CurrentHostState value of
      xyz.openbmc_project.State.Host interface will be matched with "Running".
    + If PowerState is "BiosPost" the OperatingSystemState value of
      xyz.openbmc_project.State.OperatingSystem.Status interface will be
      matched with "BiosPost".
    + If PowerState is "Always" don't match with any property, the sensors
      are always read.
2. Matching CurrentHostState with Running and OperatingSystemState
   with BiosPost are merged in the same code.
3. The abstract class such as sensor, utils have to changed when support new
   matching state.
4. It is hard to support new match condition option such as ChassisState with
   currentPowerState or any kind of the property matching.
5. The code is quite messy.

This commit restructures the code of PowerState matching.
1. Use the common ReadState name for PowerState class. ReadState can
   be the host state, chassis state, OS State, Boot progress state or any dbus
   property which have string value.
2. Include dbus object, path, interface, property and match string in
   ReadState. The readState will be sent from Fan, Cpu, Temp class to sensor
   class. Eliminate the requirement of the updating sensor code and util code
   when supports new state matching.
3. Separate the OS state and the host state matching.

Tested:
        1. Setting the sensor with PowerState="On".
        2. Make sure the value of sensor is nan when the CurrentHostState is
           is not Running.
        3. Setting the sensor with PowerState="BiosPost"
        4. Make sure the value of sensor is nan when the OperatingSystemState
           is not BiosPost.
        5. Setting the sensor with PowerState="Always"
        6. The sensor always have the value.

Signed-off-by: ThuBaNguyen <thu@os.amperecomputing.com>
---
 include/ADCSensor.hpp       |   2 +-
 include/AmpereCPU.hpp       |   4 +-
 include/ExternalSensor.hpp  |   2 +-
 include/HwmonTempSensor.hpp |   2 +-
 include/PSUEvent.hpp        |   6 +-
 include/PSUSensor.hpp       |   2 +-
 include/TachSensor.hpp      |   2 +-
 include/Utils.hpp           |  77 +++++++++++++++---
 include/sensor.hpp          |  17 ++--
 src/ADCSensor.cpp           |   2 +-
 src/ADCSensorMain.cpp       |  26 ++++++-
 src/AmpereCPU.cpp           |   2 +-
 src/AmpereCPUMain.cpp       |  11 ++-
 src/CPUSensor.cpp           |   6 +-
 src/ExitAirTempSensor.cpp   |   6 +-
 src/ExternalSensor.cpp      |   2 +-
 src/ExternalSensorMain.cpp  |   9 ++-
 src/FanMain.cpp             |  30 ++++++--
 src/HwmonTempMain.cpp       |   9 ++-
 src/HwmonTempSensor.cpp     |   2 +-
 src/IpmbSensor.cpp          |   9 ++-
 src/NVMeSensor.cpp          |   2 +-
 src/PSUEvent.cpp            |   4 +-
 src/PSUSensor.cpp           |   2 +-
 src/PSUSensorMain.cpp       |  24 ++++--
 src/TachSensor.cpp          |   2 +-
 src/Utils.cpp               | 150 +++++++++++-------------------------
 27 files changed, 239 insertions(+), 173 deletions(-)

diff --git a/include/ADCSensor.hpp b/include/ADCSensor.hpp
index 79c220a..2493c4e 100644
--- a/include/ADCSensor.hpp
+++ b/include/ADCSensor.hpp
@@ -70,7 +70,7 @@ class ADCSensor : public Sensor, public std::enable_shared_from_this<ADCSensor>
               std::shared_ptr<sdbusplus::asio::connection>& conn,
               boost::asio::io_service& io, const std::string& sensorName,
               std::vector<thresholds::Threshold>&& thresholds,
-              double scaleFactor, float pollRate, PowerState readState,
+              double scaleFactor, float pollRate, ReadState& readState,
               const std::string& sensorConfiguration,
               std::optional<BridgeGpio>&& bridgeGpio);
     ~ADCSensor() override;
diff --git a/include/AmpereCPU.hpp b/include/AmpereCPU.hpp
index df337f4..ff34ba6 100644
--- a/include/AmpereCPU.hpp
+++ b/include/AmpereCPU.hpp
@@ -24,7 +24,7 @@ class AmpereCPUSensor :
                     std::string& sensorTypeName, unsigned int factor,
                     double max, double min, bool addAssociation,
                     const std::string& label, size_t tSize,
-                    PowerState readState);
+                    const ReadState& readState);
     ~AmpereCPUSensor() override;
     void setupRead(void);
 
@@ -137,4 +137,4 @@ inline bool cpuIsPresent(const SensorData* sensorData)
     cpuPresence[gpioName] = resp;
 
     return resp;
-}
\ No newline at end of file
+}
diff --git a/include/ExternalSensor.hpp b/include/ExternalSensor.hpp
index 20dd2f0..a7562d9 100644
--- a/include/ExternalSensor.hpp
+++ b/include/ExternalSensor.hpp
@@ -22,7 +22,7 @@ class ExternalSensor :
                    std::vector<thresholds::Threshold>&& thresholdsIn,
                    const std::string& sensorConfiguration, double maxReading,
                    double minReading, double timeoutSecs,
-                   const PowerState& powerState);
+                   const ReadState& powerState);
     ~ExternalSensor() override;
 
     // Call this immediately after calling the constructor
diff --git a/include/HwmonTempSensor.hpp b/include/HwmonTempSensor.hpp
index 5cf77c3..d0c67fc 100644
--- a/include/HwmonTempSensor.hpp
+++ b/include/HwmonTempSensor.hpp
@@ -30,7 +30,7 @@ class HwmonTempSensor :
                     std::vector<thresholds::Threshold>&& thresholds,
                     const struct SensorParams& thisSensorParameters,
                     float pollRate, const std::string& sensorConfiguration,
-                    PowerState powerState);
+                    const ReadState powerState);
     ~HwmonTempSensor() override;
     void setupRead(void);
 
diff --git a/include/PSUEvent.hpp b/include/PSUEvent.hpp
index 93c06c1..db0ae79 100644
--- a/include/PSUEvent.hpp
+++ b/include/PSUEvent.hpp
@@ -34,7 +34,7 @@ class PSUSubEvent : public std::enable_shared_from_this<PSUSubEvent>
     PSUSubEvent(std::shared_ptr<sdbusplus::asio::dbus_interface> eventInterface,
                 const std::string& path,
                 std::shared_ptr<sdbusplus::asio::connection>& conn,
-                boost::asio::io_service& io, const PowerState& powerState,
+                boost::asio::io_service& io, const ReadState& readState,
                 const std::string& groupEventName, const std::string& eventName,
                 std::shared_ptr<std::set<std::string>> asserts,
                 std::shared_ptr<std::set<std::string>> combineEvent,
@@ -55,7 +55,7 @@ class PSUSubEvent : public std::enable_shared_from_this<PSUSubEvent>
     std::string path;
     std::string eventName;
 
-    PowerState readState;
+    ReadState readState;
     boost::asio::deadline_timer waitTimer;
     std::shared_ptr<boost::asio::streambuf> readBuf;
     void restartRead();
@@ -80,7 +80,7 @@ class PSUCombineEvent
         sdbusplus::asio::object_server& objectServer,
         std::shared_ptr<sdbusplus::asio::connection>& conn,
         boost::asio::io_service& io, const std::string& psuName,
-        const PowerState& powerState,
+        const ReadState& powerState,
         boost::container::flat_map<std::string, std::vector<std::string>>&
             eventPathList,
         boost::container::flat_map<
diff --git a/include/PSUSensor.hpp b/include/PSUSensor.hpp
index 9e32138..4b4240b 100644
--- a/include/PSUSensor.hpp
+++ b/include/PSUSensor.hpp
@@ -19,7 +19,7 @@ class PSUSensor : public Sensor, public std::enable_shared_from_this<PSUSensor>
               boost::asio::io_service& io, const std::string& sensorName,
               std::vector<thresholds::Threshold>&& thresholds,
               const std::string& sensorConfiguration,
-              const PowerState& powerState, const std::string& sensorUnits,
+              const ReadState& powerState, const std::string& sensorUnits,
               unsigned int factor, double max, double min, double offset,
               const std::string& label, size_t tSize, double pollRate);
     ~PSUSensor() override;
diff --git a/include/TachSensor.hpp b/include/TachSensor.hpp
index c2eaf36..5b79cff 100644
--- a/include/TachSensor.hpp
+++ b/include/TachSensor.hpp
@@ -70,7 +70,7 @@ class TachSensor : public Sensor
                std::vector<thresholds::Threshold>&& thresholds,
                const std::string& sensorConfiguration,
                const std::pair<double, double>& limits,
-               const PowerState& powerState,
+               const ReadState& powerState,
                const std::optional<std::string>& led);
     ~TachSensor() override;
 
diff --git a/include/Utils.hpp b/include/Utils.hpp
index 8fc5e80..1402732 100644
--- a/include/Utils.hpp
+++ b/include/Utils.hpp
@@ -58,9 +58,6 @@ bool findFiles(const std::filesystem::path& dirPath,
                std::string_view matchString,
                std::vector<std::filesystem::path>& foundPaths,
                int symlinkDepth = 1);
-bool isPowerOn(void);
-bool hasBiosPost(void);
-void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn);
 bool getSensorConfiguration(
     const std::string& type,
     const std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
@@ -86,8 +83,6 @@ enum class PowerState
     always
 };
 
-bool readingStateGood(const PowerState& powerState);
-
 namespace mapper
 {
 constexpr const char* busName = "xyz.openbmc_project.ObjectMapper";
@@ -109,7 +104,10 @@ const static constexpr char* busname = "xyz.openbmc_project.State.Host";
 const static constexpr char* interface = "xyz.openbmc_project.State.Host";
 const static constexpr char* path = "/xyz/openbmc_project/state/host0";
 const static constexpr char* property = "CurrentHostState";
+const static constexpr char* sOn = ".Running";
+const static constexpr char* sAlways = "Always";
 } // namespace power
+
 namespace post
 {
 const static constexpr char* busname =
@@ -118,14 +116,53 @@ const static constexpr char* interface =
     "xyz.openbmc_project.State.OperatingSystem.Status";
 const static constexpr char* path = "/xyz/openbmc_project/state/os";
 const static constexpr char* property = "OperatingSystemState";
+const static constexpr char* sBiosPost = "BiosPost";
 } // namespace post
 
+namespace chassis
+{
+const static constexpr char* busname = "xyz.openbmc_project.State.Chassis";
+const static constexpr char* interface = "xyz.openbmc_project.State.Chassis";
+const static constexpr char* path = "/xyz/openbmc_project/state/chassis0";
+const static constexpr char* property = "CurrentPowerState";
+const static constexpr char* sOn = "On";
+} // namespace chassis
+
 namespace association
 {
 const static constexpr char* interface =
     "xyz.openbmc_project.Association.Definitions";
 } // namespace association
 
+class ReadState
+{
+  public:
+    ReadState(std::string busname = power::busname,
+              std::string path = power::path,
+              std::string intf = power::interface,
+              std::string prop = power::property,
+              std::string match = power::sAlways) :
+        busname(std::move(busname)),
+        path(std::move(path)), intf(std::move(intf)), prop(std::move(prop)),
+        match(std::move(match))
+    {}
+    ~ReadState() = default;
+    std::string busname;
+    std::string path;
+    std::string intf;
+    std::string prop;
+    std::string match;
+
+    std::string getKey(void)
+    {
+        return busname + path + intf + prop + match;
+    }
+};
+
+bool isReadStateMatch(ReadState readState);
+void setupStateMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn,
+                     ReadState readState);
+
 template <typename T>
 inline T loadVariant(
     const boost::container::flat_map<std::string, BasicVariantType>& data,
@@ -155,20 +192,35 @@ inline T loadVariant(
     }
 }
 
-inline void setReadState(const std::string& str, PowerState& val)
+inline void setMatchString(const std::string& str, ReadState* val)
 {
+    if (!val)
+    {
+        std::cerr << "Invalid ReadState option!" << std::endl;
+        return;
+    }
+    val->match = str;
 
-    if (str == "On")
+    return;
+}
+
+inline ReadState initReadState(PowerState state)
+{
+
+    if (state == PowerState::on)
     {
-        val = PowerState::on;
+        return ReadState(power::busname, power::path, power::interface,
+                         power::property, power::sOn);
     }
-    else if (str == "BiosPost")
+    else if (state == PowerState::biosPost)
     {
-        val = PowerState::biosPost;
+        return ReadState(post::busname, post::path, post::interface,
+                         post::property, post::sBiosPost);
     }
-    else if (str == "Always")
+    else
     {
-        val = PowerState::always;
+        return ReadState(power::busname, power::path, power::interface,
+                         power::property, power::sAlways);
     }
 }
 
@@ -325,3 +377,4 @@ std::optional<double> readFile(const std::string& thresholdFile,
                                const double& scaleFactor);
 void setupManufacturingModeMatch(sdbusplus::asio::connection& conn);
 bool getManufacturingMode();
+bool readingStateGood(ReadState readState);
diff --git a/include/sensor.hpp b/include/sensor.hpp
index 9b1a4f4..8424342 100644
--- a/include/sensor.hpp
+++ b/include/sensor.hpp
@@ -61,7 +61,7 @@ struct Sensor
            const std::string& configurationPath, const std::string& objectType,
            bool isSettable, bool isMutable, const double max, const double min,
            std::shared_ptr<sdbusplus::asio::connection>& conn,
-           PowerState readState = PowerState::always) :
+           const ReadState& readState = initReadState(PowerState::always)) :
         name(sensor_paths::escapePathForDbus(name)),
         configurationPath(configurationPath), objectType(objectType),
         isSensorSettable(isSettable), isValueMutable(isMutable), maxValue(max),
@@ -101,7 +101,7 @@ struct Sensor
     double hysteresisTrigger;
     double hysteresisPublish;
     std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
-    PowerState readState;
+    ReadState readState;
     size_t errCount{0};
     std::unique_ptr<SensorInstrumentation> instrumentation;
 
@@ -251,9 +251,9 @@ struct Sensor
                               const std::string& label = std::string(),
                               size_t thresholdSize = 0, bool createAssoc = true)
     {
-        if (readState == PowerState::on || readState == PowerState::biosPost)
+        if (!std::empty(readState.match) && (readState.match != power::sAlways))
         {
-            setupPowerMatch(dbusConnection);
+            setupStateMatch(dbusConnection, readState);
         }
 
         if (createAssoc)
@@ -424,12 +424,9 @@ struct Sensor
 
     bool readingStateGood() const
     {
-        if (readState == PowerState::on && !isPowerOn())
-        {
-            return false;
-        }
-        if (readState == PowerState::biosPost &&
-            (!hasBiosPost() || !isPowerOn()))
+        /* Have read state match and read state don't match continue */
+        if (!std::empty(readState.match) &&
+            (readState.match != power::sAlways) && !isReadStateMatch(readState))
         {
             return false;
         }
diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
index 2a42999..3ed959b 100644
--- a/src/ADCSensor.cpp
+++ b/src/ADCSensor.cpp
@@ -46,7 +46,7 @@ ADCSensor::ADCSensor(const std::string& path,
                      boost::asio::io_service& io, const std::string& sensorName,
                      std::vector<thresholds::Threshold>&& thresholdsIn,
                      const double scaleFactor, const float pollRate,
-                     PowerState readState,
+                     ReadState& readState,
                      const std::string& sensorConfiguration,
                      std::optional<BridgeGpio>&& bridgeGpio) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
diff --git a/src/ADCSensorMain.cpp b/src/ADCSensorMain.cpp
index ef9ef44..b7233cc 100644
--- a/src/ADCSensorMain.cpp
+++ b/src/ADCSensorMain.cpp
@@ -254,13 +254,35 @@ void createSensors(
                 }
             }
 
+            bool isMatchState = false;
             auto findPowerOn = baseConfiguration->second.find("PowerState");
-            PowerState readState = PowerState::always;
+            ReadState readState = initReadState(PowerState::always);
             if (findPowerOn != baseConfiguration->second.end())
             {
                 std::string powerState =
                     std::visit(VariantToStringVisitor(), findPowerOn->second);
-                setReadState(powerState, readState);
+                /* PowerState is "On" but match string is Running */
+                if (powerState == "On")
+                {
+                    powerState = power::sOn;
+                }
+                setMatchString(powerState, &readState);
+                isMatchState = true;
+            }
+            /* Only support one state match per sensor */
+            if (!isMatchState)
+            {
+                auto findChassisMatch =
+                    baseConfiguration->second.find("ChassisState");
+                if (findChassisMatch != baseConfiguration->second.end())
+                {
+                    std::string chassisState = std::visit(
+                        VariantToStringVisitor(), findChassisMatch->second);
+                    readState = ReadState(chassis::busname, chassis::path,
+                                          chassis::interface,
+                                          chassis::property, chassisState);
+                    isMatchState = true;
+                }
             }
 
             auto& sensor = sensors[sensorName];
diff --git a/src/AmpereCPU.cpp b/src/AmpereCPU.cpp
index adf853a..1cab65a 100644
--- a/src/AmpereCPU.cpp
+++ b/src/AmpereCPU.cpp
@@ -43,7 +43,7 @@ AmpereCPUSensor::AmpereCPUSensor(
     std::vector<thresholds::Threshold>&& thresholdsIn,
     const std::string& sensorConfiguration, std::string& sensorTypeName,
     unsigned int factor, double max, double min, bool addAssociation,
-    const std::string& label, size_t tSize, PowerState readState) :
+    const std::string& label, size_t tSize, const ReadState& readState) :
     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
            std::move(thresholdsIn), sensorConfiguration, objectType, false,
            false, max, min, conn, readState),
diff --git a/src/AmpereCPUMain.cpp b/src/AmpereCPUMain.cpp
index 59594fa..1aa531b 100644
--- a/src/AmpereCPUMain.cpp
+++ b/src/AmpereCPUMain.cpp
@@ -145,7 +145,7 @@ static bool matchSensor(
         baseConfig,
     SensorData* sensorData, const std::string& interfacePath,
     const std::string& devType, const fs::path& sensorPath,
-    const std::vector<std::string>& findLabels, PowerState readState)
+    const std::vector<std::string>& findLabels, ReadState readState)
 {
     bool maxLabel = false;
     std::regex sensorNameRegEx("([A-Za-z]+)[0-9]*_");
@@ -457,12 +457,17 @@ static bool parseSensorConfig(
     }
 
     auto findPowerOn = baseConfig->second.find("PowerState");
-    PowerState readState = PowerState::always;
+    ReadState readState = initReadState(PowerState::always);
     if (findPowerOn != baseConfig->second.end())
     {
         std::string powerState =
             std::visit(VariantToStringVisitor(), findPowerOn->second);
-        setReadState(powerState, readState);
+        /* PowerState is "On" but match string is Running */
+        if (powerState == "On")
+        {
+            powerState = power::sOn;
+        }
+        setMatchString(powerState, &readState);
     }
 
     /* Find array of labels to be exposed if it is defined in config */
diff --git a/src/CPUSensor.cpp b/src/CPUSensor.cpp
index f40c96f..8fd6f68 100644
--- a/src/CPUSensor.cpp
+++ b/src/CPUSensor.cpp
@@ -42,7 +42,7 @@ CPUSensor::CPUSensor(const std::string& path, const std::string& objectType,
                      const std::string& sensorConfiguration, int cpuId,
                      bool show, double dtsOffset) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
-           objectType, false, false, 0, 0, conn, PowerState::on),
+           objectType, false, false, 0, 0, conn, initReadState(PowerState::on)),
     objServer(objectServer), inputDev(io), waitTimer(io),
     nameTcontrol("Tcontrol CPU" + std::to_string(cpuId)), path(path),
     privTcontrol(std::numeric_limits<double>::quiet_NaN()),
@@ -89,7 +89,7 @@ CPUSensor::CPUSensor(const std::string& path, const std::string& objectType,
     }
 
     // call setup always as not all sensors call setInitialProperties
-    setupPowerMatch(conn);
+    setupStateMatch(conn, readState);
 }
 
 CPUSensor::~CPUSensor()
@@ -199,7 +199,7 @@ void CPUSensor::updateMinMaxValues(void)
                 }
                 else
                 {
-                    if (isPowerOn())
+                    if (isReadStateMatch(readState))
                     {
                         updateProperty(sensorInterface, oldValue, 0, dbusName);
                     }
diff --git a/src/ExitAirTempSensor.cpp b/src/ExitAirTempSensor.cpp
index 67c690f..b368084 100644
--- a/src/ExitAirTempSensor.cpp
+++ b/src/ExitAirTempSensor.cpp
@@ -162,7 +162,7 @@ CFMSensor::CFMSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
                      std::shared_ptr<ExitAirTempSensor>& parent) :
     Sensor(escapeName(sensorName), std::move(thresholdData),
            sensorConfiguration, "xyz.openbmc_project.Configuration.ExitAirTemp",
-           false, false, cfmMaxReading, cfmMinReading, conn, PowerState::on),
+           false, false, cfmMaxReading, cfmMinReading, conn, initReadState(PowerState::on)),
     parent(parent), objServer(objectServer)
 {
     sensorInterface = objectServer.add_interface(
@@ -503,7 +503,7 @@ ExitAirTempSensor::ExitAirTempSensor(
     Sensor(escapeName(sensorName), std::move(thresholdData),
            sensorConfiguration, "xyz.openbmc_project.Configuration.ExitAirTemp",
            false, false, exitAirMaxReading, exitAirMinReading, conn,
-           PowerState::on),
+           initReadState(PowerState::on)),
     objServer(objectServer)
 {
     sensorInterface = objectServer.add_interface(
@@ -713,7 +713,7 @@ bool ExitAirTempSensor::calculate(double& val)
     }
 
     // if fans are off, just make the exit temp equal to inlet
-    if (!isPowerOn())
+    if (!isReadStateMatch(readState))
     {
         val = inletTemp;
         return true;
diff --git a/src/ExternalSensor.cpp b/src/ExternalSensor.cpp
index cc9e7c5..5dbba2d 100644
--- a/src/ExternalSensor.cpp
+++ b/src/ExternalSensor.cpp
@@ -25,7 +25,7 @@ ExternalSensor::ExternalSensor(
     const std::string& sensorName, const std::string& sensorUnits,
     std::vector<thresholds::Threshold>&& thresholdsIn,
     const std::string& sensorConfiguration, double maxReading,
-    double minReading, double timeoutSecs, const PowerState& powerState) :
+    double minReading, double timeoutSecs, const ReadState& powerState) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
            objectType, true, true, maxReading, minReading, conn, powerState),
     objServer(objectServer), writeLast(std::chrono::steady_clock::now()),
diff --git a/src/ExternalSensorMain.cpp b/src/ExternalSensorMain.cpp
index cbe2388..6299374 100644
--- a/src/ExternalSensorMain.cpp
+++ b/src/ExternalSensorMain.cpp
@@ -308,12 +308,17 @@ void createSensors(
             }
 
             auto findPowerOn = baseConfiguration.second.find("PowerState");
-            PowerState readState = PowerState::always;
+            ReadState readState = initReadState(PowerState::always);
             if (findPowerOn != baseConfiguration.second.end())
             {
                 std::string powerState =
                     std::visit(VariantToStringVisitor(), findPowerOn->second);
-                setReadState(powerState, readState);
+                /* PowerState is "On" but match string is Running */
+                if (powerState == "On")
+                {
+                    powerState = power::sOn;
+                }
+                setMatchString(powerState, &readState);
             }
 
             auto& sensorEntry = sensors[sensorName];
diff --git a/src/FanMain.cpp b/src/FanMain.cpp
index ff0ffaa..e664909 100644
--- a/src/FanMain.cpp
+++ b/src/FanMain.cpp
@@ -405,15 +405,35 @@ void createSensors(
                 redundancy = &systemRedundancy;
             }
 
-            PowerState powerState = PowerState::on;
+            bool isMatchState = false;
+            ReadState powerState = initReadState(PowerState::on);
             auto findPower = baseConfiguration->second.find("PowerState");
             if (findPower != baseConfiguration->second.end())
             {
-                const auto* ptrPower =
-                    std::get_if<std::string>(&(findPower->second));
-                if (ptrPower != nullptr)
+                std::string sPower =
+                     std::visit(VariantToStringVisitor(), findPower->second);
+                /* PowerState is "On" but match string is Running */
+                if (sPower == "On")
                 {
-                    setReadState(*ptrPower, powerState);
+                    sPower = power::sOn;
+                }
+                setMatchString(sPower, &powerState);
+                isMatchState = true;
+            }
+
+            /* Only support one state match per sensor */
+            if (!isMatchState)
+            {
+                auto findChassisMatch =
+                    baseConfiguration->second.find("ChassisState");
+                if (findChassisMatch != baseConfiguration->second.end())
+                {
+                    std::string chassisState = std::visit(
+                        VariantToStringVisitor(), findChassisMatch->second);
+                    powerState = ReadState(chassis::busname, chassis::path,
+                                           chassis::interface,
+                                           chassis::property, chassisState);
+                    isMatchState = true;
                 }
             }
 
diff --git a/src/HwmonTempMain.cpp b/src/HwmonTempMain.cpp
index 988e8b9..82fea6f 100644
--- a/src/HwmonTempMain.cpp
+++ b/src/HwmonTempMain.cpp
@@ -401,12 +401,17 @@ void createSensors(
             }
 
             auto findPowerOn = baseConfigMap.find("PowerState");
-            PowerState readState = PowerState::always;
+            ReadState readState = initReadState(PowerState::always);
             if (findPowerOn != baseConfigMap.end())
             {
                 std::string powerState =
                     std::visit(VariantToStringVisitor(), findPowerOn->second);
-                setReadState(powerState, readState);
+                /* PowerState is "On" but match string is Running */
+                if (powerState == "On")
+                {
+                    powerState = power::sOn;
+                }
+                setMatchString(powerState, &readState);
             }
 
             auto permitSet = getPermitSet(baseConfigMap);
diff --git a/src/HwmonTempSensor.cpp b/src/HwmonTempSensor.cpp
index 7eb5e8f..136c21e 100644
--- a/src/HwmonTempSensor.cpp
+++ b/src/HwmonTempSensor.cpp
@@ -46,7 +46,7 @@ HwmonTempSensor::HwmonTempSensor(
     boost::asio::io_service& io, const std::string& sensorName,
     std::vector<thresholds::Threshold>&& thresholdsIn,
     const struct SensorParams& thisSensorParameters, const float pollRate,
-    const std::string& sensorConfiguration, const PowerState powerState) :
+    const std::string& sensorConfiguration, const ReadState powerState) :
     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
            std::move(thresholdsIn), sensorConfiguration, objectType, false,
            false, thisSensorParameters.maxValue, thisSensorParameters.minValue,
diff --git a/src/IpmbSensor.cpp b/src/IpmbSensor.cpp
index 8d4dfaa..fb6470c 100644
--- a/src/IpmbSensor.cpp
+++ b/src/IpmbSensor.cpp
@@ -66,7 +66,7 @@ IpmbSensor::IpmbSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
                        const float pollRate, std::string& sensorTypeName) :
     Sensor(escapeName(sensorName), std::move(thresholdData),
            sensorConfiguration, "xyz.openbmc_project.Configuration.ExitAirTemp",
-           false, false, ipmbMaxReading, ipmbMinReading, conn, PowerState::on),
+           false, false, ipmbMaxReading, ipmbMinReading, conn, initReadState(PowerState::on)),
     deviceAddress(deviceAddress), hostSMbusIndex(hostSMbusIndex),
     sensorPollMs(static_cast<int>(pollRate * 1000)), objectServer(objectServer),
     waitTimer(io)
@@ -482,7 +482,12 @@ void IpmbSensor::parseConfigValues(const SensorBaseConfigMap& entry)
         std::string powerState =
             std::visit(VariantToStringVisitor(), findPowerState->second);
 
-        setReadState(powerState, readState);
+        /* PowerState is "On" but match string is Running */
+        if (powerState == "On")
+        {
+            powerState = power::sOn;
+        }
+        setMatchString(powerState, &(readState));
     }
 }
 
diff --git a/src/NVMeSensor.cpp b/src/NVMeSensor.cpp
index a5257f5..b7eaa60 100644
--- a/src/NVMeSensor.cpp
+++ b/src/NVMeSensor.cpp
@@ -30,7 +30,7 @@ NVMeSensor::NVMeSensor(sdbusplus::asio::object_server& objectServer,
                        const int busNumber) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
            NVMeSensor::configType, false, false, maxReading, minReading, conn,
-           PowerState::on),
+           initReadState(PowerState::on)),
     bus(busNumber), objServer(objectServer)
 {
     if (bus < 0)
diff --git a/src/PSUEvent.cpp b/src/PSUEvent.cpp
index d1cb40e..2bf3d16 100644
--- a/src/PSUEvent.cpp
+++ b/src/PSUEvent.cpp
@@ -35,7 +35,7 @@ PSUCombineEvent::PSUCombineEvent(
     sdbusplus::asio::object_server& objectServer,
     std::shared_ptr<sdbusplus::asio::connection>& conn,
     boost::asio::io_service& io, const std::string& psuName,
-    const PowerState& powerState,
+    const ReadState& powerState,
     boost::container::flat_map<std::string, std::vector<std::string>>&
         eventPathList,
     boost::container::flat_map<
@@ -141,7 +141,7 @@ static boost::container::flat_map<std::string,
 PSUSubEvent::PSUSubEvent(
     std::shared_ptr<sdbusplus::asio::dbus_interface> eventInterface,
     const std::string& path, std::shared_ptr<sdbusplus::asio::connection>& conn,
-    boost::asio::io_service& io, const PowerState& powerState,
+    boost::asio::io_service& io, const ReadState& powerState,
     const std::string& groupEventName, const std::string& eventName,
     std::shared_ptr<std::set<std::string>> asserts,
     std::shared_ptr<std::set<std::string>> combineEvent,
diff --git a/src/PSUSensor.cpp b/src/PSUSensor.cpp
index bf75e61..f95218f 100644
--- a/src/PSUSensor.cpp
+++ b/src/PSUSensor.cpp
@@ -41,7 +41,7 @@ PSUSensor::PSUSensor(const std::string& path, const std::string& objectType,
                      boost::asio::io_service& io, const std::string& sensorName,
                      std::vector<thresholds::Threshold>&& thresholdsIn,
                      const std::string& sensorConfiguration,
-                     const PowerState& powerState,
+                     const ReadState& powerState,
                      const std::string& sensorUnits, unsigned int factor,
                      double max, double min, double offset,
                      const std::string& label, size_t tSize, double pollRate) :
diff --git a/src/PSUSensorMain.cpp b/src/PSUSensorMain.cpp
index c710b4d..6b1ca7e 100644
--- a/src/PSUSensorMain.cpp
+++ b/src/PSUSensorMain.cpp
@@ -485,13 +485,18 @@ static void createSensorsCallback(
         checkGroupEvent(directory.string(), groupEventMatch,
                         groupEventPathList);
 
-        PowerState readState = PowerState::always;
         auto findPowerOn = baseConfig->second.find("PowerState");
+        ReadState readState = initReadState(PowerState::always);
         if (findPowerOn != baseConfig->second.end())
         {
-            std::string powerState =
-                std::visit(VariantToStringVisitor(), findPowerOn->second);
-            setReadState(powerState, readState);
+            std::string powerState = std::visit(
+                VariantToStringVisitor(), findPowerOn->second);
+            /* PowerState is "On" but match string is Running */
+            if (powerState == "On")
+            {
+                powerState = power::sOn;
+            }
+            setMatchString(powerState, &readState);
         }
 
         /* Check if there are more sensors in the same interface */
@@ -773,9 +778,14 @@ static void createSensorsCallback(
             auto findPowerState = baseConfig->second.find(keyPowerState);
             if (findPowerState != baseConfig->second.end())
             {
-                std::string powerState = std::visit(VariantToStringVisitor(),
-                                                    findPowerState->second);
-                setReadState(powerState, readState);
+                std::string powerState = std::visit(
+                   VariantToStringVisitor(), findPowerOn->second);
+                /* PowerState is "On" but match string is Running */
+                if (powerState == "On")
+                {
+                    powerState = power::sOn;
+                }
+                setMatchString(powerState, &readState);
             }
             if (!(psuProperty->minReading < psuProperty->maxReading))
             {
diff --git a/src/TachSensor.cpp b/src/TachSensor.cpp
index 9afe094..17a9699 100644
--- a/src/TachSensor.cpp
+++ b/src/TachSensor.cpp
@@ -47,7 +47,7 @@ TachSensor::TachSensor(const std::string& path, const std::string& objectType,
                        std::vector<thresholds::Threshold>&& thresholdsIn,
                        const std::string& sensorConfiguration,
                        const std::pair<double, double>& limits,
-                       const PowerState& powerState,
+                       const ReadState& powerState,
                        const std::optional<std::string>& ledIn) :
     Sensor(escapeName(fanName), std::move(thresholdsIn), sensorConfiguration,
            objectType, false, false, limits.second, limits.first, conn,
diff --git a/src/Utils.cpp b/src/Utils.cpp
index 954a5d3..502126e 100644
--- a/src/Utils.cpp
+++ b/src/Utils.cpp
@@ -35,12 +35,12 @@
 
 namespace fs = std::filesystem;
 
-static bool powerStatusOn = false;
-static bool biosHasPost = false;
 static bool manufacturingMode = false;
 
-static std::unique_ptr<sdbusplus::bus::match::match> powerMatch = nullptr;
-static std::unique_ptr<sdbusplus::bus::match::match> postMatch = nullptr;
+boost::container::flat_map<std::string, bool> isStateMatch;
+boost::container::flat_map<std::string,
+                           std::unique_ptr<sdbusplus::bus::match::match>>
+    stateMatch;
 
 /**
  * return the contents of a file
@@ -296,31 +296,21 @@ bool findFiles(const fs::path& dirPath, std::string_view matchString,
     return true;
 }
 
-bool isPowerOn(void)
+bool isReadStateMatch(ReadState readState)
 {
-    if (!powerMatch)
+    std::string key = readState.getKey();
+    if (stateMatch.find(key) == stateMatch.end())
     {
         throw std::runtime_error("Power Match Not Created");
     }
-    return powerStatusOn;
+    return isStateMatch[key];
 }
 
-bool hasBiosPost(void)
+bool readingStateGood(ReadState readState)
 {
-    if (!postMatch)
-    {
-        throw std::runtime_error("Post Match Not Created");
-    }
-    return biosHasPost;
-}
-
-bool readingStateGood(const PowerState& powerState)
-{
-    if (powerState == PowerState::on && !isPowerOn())
-    {
-        return false;
-    }
-    if (powerState == PowerState::biosPost && (!hasBiosPost() || !isPowerOn()))
+    /* Have read state match and read state don't match continue */
+    if (!std::empty(readState.match) &&
+        (readState.match != power::sAlways) && !isReadStateMatch(readState))
     {
         return false;
     }
@@ -329,12 +319,15 @@ bool readingStateGood(const PowerState& powerState)
 }
 
 static void
-    getPowerStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn,
-                   size_t retries = 2)
+    getStateStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn,
+                   std::string busname, std::string path, std::string intf,
+                   std::string prop, std::string match, size_t retries = 2)
 {
     conn->async_method_call(
-        [conn, retries](boost::system::error_code ec,
-                        const std::variant<std::string>& state) {
+        [conn, retries, busname, path, intf, prop,
+         match](boost::system::error_code ec,
+                const std::variant<std::string>& state) {
+            std::string key = busname + path + intf + prop + match;
         if (ec)
         {
             if (retries != 0U)
@@ -342,10 +335,12 @@ static void
                 auto timer = std::make_shared<boost::asio::steady_timer>(
                     conn->get_io_context());
                 timer->expires_after(std::chrono::seconds(15));
-                timer->async_wait(
-                    [timer, conn, retries](boost::system::error_code) {
-                    getPowerStatus(conn, retries - 1);
-                });
+                timer->async_wait([timer, conn, retries, busname, path,
+                                       intf, prop,
+                                       match](boost::system::error_code) {
+                        getStateStatus(conn, busname, path, intf, prop, match,
+                                       retries - 1);
+                    });
                 return;
             }
 
@@ -354,81 +349,50 @@ static void
             std::cerr << "error getting power status " << ec.message() << "\n";
             return;
         }
-        powerStatusOn =
-            boost::ends_with(std::get<std::string>(state), ".Running");
+        isStateMatch[key] =
+            boost::ends_with(std::get<std::string>(state), match);
         },
-        power::busname, power::path, properties::interface, properties::get,
-        power::interface, power::property);
+        busname, path, properties::interface, properties::get, intf, prop);
 }
 
-static void
-    getPostStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn,
-                  size_t retries = 2)
-{
-    conn->async_method_call(
-        [conn, retries](boost::system::error_code ec,
-                        const std::variant<std::string>& state) {
-        if (ec)
-        {
-            if (retries != 0U)
-            {
-                auto timer = std::make_shared<boost::asio::steady_timer>(
-                    conn->get_io_context());
-                timer->expires_after(std::chrono::seconds(15));
-                timer->async_wait(
-                    [timer, conn, retries](boost::system::error_code) {
-                    getPostStatus(conn, retries - 1);
-                });
-                return;
-            }
-            // we commonly come up before power control, we'll capture the
-            // property change later
-            std::cerr << "error getting post status " << ec.message() << "\n";
-            return;
-        }
-        const auto& value = std::get<std::string>(state);
-        biosHasPost = (value != "Inactive") &&
-                      (value != "xyz.openbmc_project.State.OperatingSystem."
-                                "Status.OSStatus.Inactive");
-        },
-        post::busname, post::path, properties::interface, properties::get,
-        post::interface, post::property);
-}
-
-void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
+void setupStateMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn,
+                     ReadState matchState)
 {
     static boost::asio::steady_timer timer(conn->get_io_context());
-    // create a match for powergood changes, first time do a method call to
+    std::string key = matchState.getKey();
+    std::string prop = matchState.prop;
+    std::string match = matchState.match;
+
+    // create a match for read state changes, first time do a method call to
     // cache the correct value
-    if (powerMatch)
+    if (stateMatch.find(key) != stateMatch.end())
     {
         return;
     }
 
-    powerMatch = std::make_unique<sdbusplus::bus::match::match>(
+    stateMatch[key] = std::make_unique<sdbusplus::bus::match::match>(
         static_cast<sdbusplus::bus::bus&>(*conn),
         "type='signal',interface='" + std::string(properties::interface) +
-            "',path='" + std::string(power::path) + "',arg0='" +
-            std::string(power::interface) + "'",
-        [](sdbusplus::message::message& message) {
+            "',path='" + std::string(matchState.path) + "',arg0='" +
+            std::string(matchState.intf) + "'",
+        [prop, match, key](sdbusplus::message::message& message) {
         std::string objectName;
         boost::container::flat_map<std::string, std::variant<std::string>>
             values;
         message.read(objectName, values);
-        auto findState = values.find(power::property);
+        auto findState = values.find(prop);
         if (findState != values.end())
         {
-            bool on = boost::ends_with(std::get<std::string>(findState->second),
-                                       ".Running");
+            bool on = boost::ends_with(std::get<std::string>(findState->second), match);
             if (!on)
             {
                 timer.cancel();
-                powerStatusOn = false;
+                isStateMatch[key] = false;
                 return;
             }
             // on comes too quickly
             timer.expires_after(std::chrono::seconds(10));
-            timer.async_wait([](boost::system::error_code ec) {
+            timer.async_wait([key](boost::system::error_code ec) {
                 if (ec == boost::asio::error::operation_aborted)
                 {
                     return;
@@ -438,33 +402,13 @@ void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
                     std::cerr << "Timer error " << ec.message() << "\n";
                     return;
                 }
-                powerStatusOn = true;
+                isStateMatch[key] = true;
             });
         }
         });
 
-    postMatch = std::make_unique<sdbusplus::bus::match::match>(
-        static_cast<sdbusplus::bus::bus&>(*conn),
-        "type='signal',interface='" + std::string(properties::interface) +
-            "',path='" + std::string(post::path) + "',arg0='" +
-            std::string(post::interface) + "'",
-        [](sdbusplus::message::message& message) {
-        std::string objectName;
-        boost::container::flat_map<std::string, std::variant<std::string>>
-            values;
-        message.read(objectName, values);
-        auto findState = values.find(post::property);
-        if (findState != values.end())
-        {
-            auto& value = std::get<std::string>(findState->second);
-            biosHasPost = (value != "Inactive") &&
-                          (value != "xyz.openbmc_project.State.OperatingSystem."
-                                    "Status.OSStatus.Inactive");
-        }
-        });
-
-    getPowerStatus(conn);
-    getPostStatus(conn);
+    getStateStatus(conn, matchState.busname, matchState.path, matchState.intf,
+                   matchState.prop, matchState.match, 2);
 }
 
 // replaces limits if MinReading and MaxReading are found.
-- 
2.25.1

