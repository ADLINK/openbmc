From 205e2d43f21d032a785fd7dc1efc1d0e22ab7a20 Mon Sep 17 00:00:00 2001
From: Chau Ly <chaul@amperecomputing.com>
Date: Wed, 26 Oct 2022 04:12:52 +0000
Subject: [PATCH 7/7] intrusionsensor: Add Rearm property

This patch adds Rearm property to intrusionsensor service, under
"xyz.openbmc_project.Chassis.Intrusion" interface, to specify the method
for rearming the chassis cover and updating the "Status" property.
As defined in Redfish schema specification, this property is optional.
If not set, "Rearm" will default to "Automatic", which will directly
update the raw chassis intrusion status to the "Status" property.
If set to "Manual", after an intrusion event, the "Status" property
will be kept to "HardwareIntrusion" until a reset action happens for it
to be set to "Normal" (manual rearm). The rearm action comes from
Redfish by writing "Normal" to the "IntrusionSensor" property in
/redfish/v1/Chassis/chassis.

Example:
{
     "Class": "Aspeed2600_Hwmon",
     "Name": "Chassis_Intrusion_Status",
     "Rearm": "Manual",
     "Type": "ChassisIntrusionSensor"
}

Tested: This has been tested on Ampere's Mt.Mitchell platform using
hwmon reading method.

Automatic mode (default):
1. The chassis cover is closed => the Status property shows "Normal"
2. The chassis cover is open => Status shows "HardwareIntrusion"

Manual mode:
1. The chassis cover is first open from the last rearm action =>
"HardwareIntrusion"
2. The chassis cover is closed => "HardwareIntrusion"
3. The chassis cover is open again => "HardwareIntrusion"
4. The rearm action is taken => "Normal"
5. The chassis cover is closed => "Normal"

Signed-off-by: Chau Ly <chaul@amperecomputing.com>
Change-Id: I8257a5fee9db67a072e7fafc140f6a143028c429
---
 src/ChassisIntrusionSensor.cpp | 98 ++++++++++++++++++++++++----------
 src/ChassisIntrusionSensor.hpp | 14 ++---
 src/IntrusionSensorMain.cpp    | 19 +++++--
 3 files changed, 94 insertions(+), 37 deletions(-)

diff --git a/src/ChassisIntrusionSensor.cpp b/src/ChassisIntrusionSensor.cpp
index 3066359..336e32e 100644
--- a/src/ChassisIntrusionSensor.cpp
+++ b/src/ChassisIntrusionSensor.cpp
@@ -47,6 +47,7 @@ static constexpr unsigned int sensorFailedPollSec = 5;
 static unsigned int intrusionSensorPollSec = defaultPollSec;
 static constexpr const char* hwIntrusionValStr = "HardwareIntrusion";
 static constexpr const char* normalValStr = "Normal";
+static constexpr const char* manualRearmStr = "Manual";
 
 // SMLink Status Register
 const static constexpr size_t pchStatusRegIntrusion = 0x04;
@@ -61,7 +62,7 @@ void ChassisIntrusionSensor::updateValue(const size_t& value)
 {
     std::string newValue = value != 0 ? hwIntrusionValStr : normalValStr;
 
-    // Take no action if value already equal
+    // Take no action if the hardware status does not change
     // Same semantics as Sensor::updateValue(const double&)
     if (newValue == mValue)
     {
@@ -74,27 +75,37 @@ void ChassisIntrusionSensor::updateValue(const size_t& value)
                   << "\n";
     }
 
+    // Automatic Rearm mode allows direct update
+    // Manual Rearm mode requires a rearm action to clear the intrusion
+    // status
+    if (mRearm == manualRearmStr)
+    {
+        if (newValue == normalValStr)
+        {
+            // Chassis is first closed from being open. If it has been
+            // rearmed externally, reset the flag, update mValue and
+            // return, without having to write "Normal" to DBus property
+            // (because the rearm action already did).
+            // Otherwise, return with no more action.
+            if (mRearmFlag)
+            {
+                mRearmFlag = false;
+                mValue = newValue;
+            }
+            return;
+        }
+    }
+
+    // Flush the rearm flag everytime it allows an update to Dbus
+    mRearmFlag = false;
+
     // indicate that it is internal set call
+    mOverridenState = false;
     mInternalSet = true;
     mIface->set_property("Status", newValue);
     mInternalSet = false;
 
     mValue = newValue;
-
-    if (mOldValue == normalValStr && mValue != normalValStr)
-    {
-        sd_journal_send("MESSAGE=%s", "Chassis intrusion assert event",
-                        "PRIORITY=%i", LOG_INFO, "REDFISH_MESSAGE_ID=%s",
-                        "OpenBMC.0.1.ChassisIntrusionDetected", NULL);
-        mOldValue = mValue;
-    }
-    else if (mOldValue == hwIntrusionValStr && mValue == normalValStr)
-    {
-        sd_journal_send("MESSAGE=%s", "Chassis intrusion de-assert event",
-                        "PRIORITY=%i", LOG_INFO, "REDFISH_MESSAGE_ID=%s",
-                        "OpenBMC.0.1.ChassisIntrusionReset", NULL);
-        mOldValue = mValue;
-    }
 }
 
 int ChassisIntrusionPchSensor::readSensor()
@@ -281,13 +292,42 @@ int ChassisIntrusionSensor::setSensorValue(const std::string& req,
 {
     if (!mInternalSet)
     {
-        propertyValue = req;
-        mOverridenState = true;
+        /*
+           1. Assuming that setting property in Automatic mode causes
+           no effect but only event logs and propertiesChanged signal
+           (because the property will be updated continuously to the
+           current hardware status anyway), only update Status property
+           and raise rearm flag in Manual rearm mode.
+           2. Only accept Normal value from an external call.
+        */
+        if (mRearm == manualRearmStr && req == normalValStr)
+        {
+            mRearmFlag = true;
+            propertyValue = req;
+            mOverridenState = true;
+        }
     }
     else if (!mOverridenState)
     {
         propertyValue = req;
     }
+    else
+    {
+        return 1;
+    }
+    // Send intrusion event to Redfish
+    if (mValue == normalValStr && propertyValue != normalValStr)
+    {
+        sd_journal_send("MESSAGE=%s", "Chassis intrusion assert event",
+                        "PRIORITY=%i", LOG_INFO, "REDFISH_MESSAGE_ID=%s",
+                        "OpenBMC.0.1.ChassisIntrusionDetected", NULL);
+    }
+    else if (mValue == hwIntrusionValStr && propertyValue == normalValStr)
+    {
+        sd_journal_send("MESSAGE=%s", "Chassis intrusion de-assert event",
+                        "PRIORITY=%i", LOG_INFO, "REDFISH_MESSAGE_ID=%s",
+                        "OpenBMC.0.1.ChassisIntrusionReset", NULL);
+    }
     return 1;
 }
 
@@ -298,12 +338,14 @@ void ChassisIntrusionSensor::start()
         [&](const std::string& req, std::string& propertyValue) {
         return setSensorValue(req, propertyValue);
         });
+    mIface->register_property("Rearm", mRearm);
     mIface->initialize();
     pollSensorStatus();
 }
 
 ChassisIntrusionSensor::ChassisIntrusionSensor(
-    sdbusplus::asio::object_server& objServer) :
+    std::string rearm, sdbusplus::asio::object_server& objServer) :
+    mRearm(std::move(rearm)),
     mObjServer(objServer)
 {
     mIface = mObjServer.add_interface("/xyz/openbmc_project/Chassis/Intrusion",
@@ -311,9 +353,9 @@ ChassisIntrusionSensor::ChassisIntrusionSensor(
 }
 
 ChassisIntrusionPchSensor::ChassisIntrusionPchSensor(
-    boost::asio::io_context& io, sdbusplus::asio::object_server& objServer,
-    int busId, int slaveAddr) :
-    ChassisIntrusionSensor(objServer),
+    std::string rearm, boost::asio::io_context& io,
+    sdbusplus::asio::object_server& objServer, int busId, int slaveAddr) :
+    ChassisIntrusionSensor(std::move(rearm), objServer),
     mPollTimer(io)
 {
     if (busId < 0 || slaveAddr <= 0)
@@ -355,9 +397,9 @@ ChassisIntrusionPchSensor::ChassisIntrusionPchSensor(
 }
 
 ChassisIntrusionGpioSensor::ChassisIntrusionGpioSensor(
-    boost::asio::io_context& io, sdbusplus::asio::object_server& objServer,
-    bool gpioInverted) :
-    ChassisIntrusionSensor(objServer),
+    std::string rearm, boost::asio::io_context& io,
+    sdbusplus::asio::object_server& objServer, bool gpioInverted) :
+    ChassisIntrusionSensor(std::move(rearm), objServer),
     mGpioInverted(gpioInverted), mGpioFd(io)
 {
     mGpioLine = gpiod::find_line(mPinName);
@@ -380,9 +422,9 @@ ChassisIntrusionGpioSensor::ChassisIntrusionGpioSensor(
 }
 
 ChassisIntrusionHwmonSensor::ChassisIntrusionHwmonSensor(
-    boost::asio::io_context& io, sdbusplus::asio::object_server& objServer,
-    std::string hwmonName) :
-    ChassisIntrusionSensor(objServer),
+    std::string rearm, boost::asio::io_context& io,
+    sdbusplus::asio::object_server& objServer, std::string hwmonName) :
+    ChassisIntrusionSensor(std::move(rearm), objServer),
     mHwmonName(std::move(hwmonName)), mPollTimer(io)
 {
     std::vector<fs::path> paths;
diff --git a/src/ChassisIntrusionSensor.hpp b/src/ChassisIntrusionSensor.hpp
index e3b84cf..cb565a8 100644
--- a/src/ChassisIntrusionSensor.hpp
+++ b/src/ChassisIntrusionSensor.hpp
@@ -13,7 +13,8 @@ namespace fs = std::filesystem;
 class ChassisIntrusionSensor
 {
   public:
-    explicit ChassisIntrusionSensor(sdbusplus::asio::object_server& objServer);
+    explicit ChassisIntrusionSensor(std::string rearm,
+                                    sdbusplus::asio::object_server& objServer);
 
     virtual ~ChassisIntrusionSensor();
 
@@ -26,12 +27,13 @@ class ChassisIntrusionSensor
 
   private:
     // intrusion status. 0: not intruded, 1: intruded
-    std::string mValue = "unknown";
-    std::string mOldValue = "Normal";
+    std::string mValue = "Normal";
+    std::string mRearm = "Automatic";
     std::shared_ptr<sdbusplus::asio::dbus_interface> mIface;
     sdbusplus::asio::object_server& mObjServer;
     bool mOverridenState = false;
     bool mInternalSet = false;
+    bool mRearmFlag = false;
 
     int setSensorValue(const std::string& req, std::string& propertyValue);
 };
@@ -41,7 +43,7 @@ class ChassisIntrusionPchSensor :
     public std::enable_shared_from_this<ChassisIntrusionPchSensor>
 {
   public:
-    ChassisIntrusionPchSensor(boost::asio::io_context& io,
+    ChassisIntrusionPchSensor(std::string rearm, boost::asio::io_context& io,
                               sdbusplus::asio::object_server& objServer,
                               int busId, int slaveAddr);
 
@@ -60,7 +62,7 @@ class ChassisIntrusionGpioSensor :
     public std::enable_shared_from_this<ChassisIntrusionGpioSensor>
 {
   public:
-    ChassisIntrusionGpioSensor(boost::asio::io_context& io,
+    ChassisIntrusionGpioSensor(std::string rearm, boost::asio::io_context& io,
                                sdbusplus::asio::object_server& objServer,
                                bool gpioInverted);
 
@@ -80,7 +82,7 @@ class ChassisIntrusionHwmonSensor :
     public std::enable_shared_from_this<ChassisIntrusionHwmonSensor>
 {
   public:
-    ChassisIntrusionHwmonSensor(boost::asio::io_context& io,
+    ChassisIntrusionHwmonSensor(std::string rearm, boost::asio::io_context& io,
                                 sdbusplus::asio::object_server& objServer,
                                 std::string hwmonName);
 
diff --git a/src/IntrusionSensorMain.cpp b/src/IntrusionSensorMain.cpp
index 3545233..dcce4fe 100644
--- a/src/IntrusionSensorMain.cpp
+++ b/src/IntrusionSensorMain.cpp
@@ -89,6 +89,19 @@ static void createSensorsFromConfig(
 
         baseConfiguration = &(*sensorBase);
 
+        // Rearm defaults to "Automatic" mode
+        std::string rearm = "Automatic";
+        auto findRearm = baseConfiguration->second.find("Rearm");
+        if (findRearm != baseConfiguration->second.end())
+        {
+            rearm = std::get<std::string>(findRearm->second);
+            if (rearm != "Automatic" && rearm != "Manual")
+            {
+                std::cerr << "Wrong input for Rearm parameter\n";
+                continue;
+            }
+        }
+
         // judge class, "Gpio", "Hwmon" or "I2C"
         auto findClass = baseConfiguration->second.find("Class");
         if (findClass != baseConfiguration->second.end())
@@ -112,7 +125,7 @@ static void createSensorsFromConfig(
                         (std::get<std::string>(findGpioPolarity->second) ==
                          "Low");
                     pSensor = std::make_shared<ChassisIntrusionGpioSensor>(
-                        io, objServer, gpioInverted);
+                        rearm, io, objServer, gpioInverted);
                     pSensor->start();
                     if (debug)
                     {
@@ -152,7 +165,7 @@ static void createSensorsFromConfig(
                 try
                 {
                     pSensor = std::make_shared<ChassisIntrusionHwmonSensor>(
-                        io, objServer, hwmonName);
+                        rearm, io, objServer, hwmonName);
                     pSensor->start();
                     return;
                 }
@@ -178,7 +191,7 @@ static void createSensorsFromConfig(
                     int busId = std::get<uint64_t>(findBus->second);
                     int slaveAddr = std::get<uint64_t>(findAddress->second);
                     pSensor = std::make_shared<ChassisIntrusionPchSensor>(
-                        io, objServer, busId, slaveAddr);
+                        rearm, io, objServer, busId, slaveAddr);
                     pSensor->start();
                     if (debug)
                     {
-- 
2.25.1

