From 74c8605da558448a197c8ad3e9c9e770695a288d Mon Sep 17 00:00:00 2001
From: ThuBaNguyen <thu@os.amperecomputing.com>
Date: Tue, 16 Aug 2022 12:04:40 +0700
Subject: [PATCH] Restructure the code handle PowerState attribute

There are some below issues with the code handle PowerState attribute:
1. Use difference properties to the "PowerState" configuration.
    + If the PowerState is "On" the CurrentHostState value of
      xyz.openbmc_project.State.Host interface will be matched with "Running".
    + If PowerState is "BiosPost" the OperatingSystemState value of
      xyz.openbmc_project.State.OperatingSystem.Status interface will be
      matched with "BiosPost".
    + If PowerState is "Always" don't match with any property, the sensors
      are always read.
2. Matching CurrentHostState with Running and OperatingSystemState
   with BiosPost are merged in the same code.
3. The abstract class such as sensor, utils have to changed when support new
   matching state.
4. It is hard to support new match condition option such as ChassisState with
   currentPowerState or any kind of the property matching.
5. The code is quite messy.

This commit restructures the code of PowerState matching.
1. Use the common ReadState name for PowerState class. ReadState can
   be the host state, chassis state, OS State, Boot progress state or any dbus
   property which have string value.
2. Include dbus object, path, interface, property and match string in
   ReadState. The readState will be sent from Fan, Cpu, Temp class to sensor
   class. Eliminate the requirement of the updating sensor code and util code
   when supports new state matching.
3. Separate the OS state and the host state matching.

Tested:
        1. Setting the sensor with PowerState="On".
        2. Make sure the value of sensor is nan when the CurrentHostState is
           is not Running.
        3. Setting the sensor with PowerState="BiosPost"
        4. Make sure the value of sensor is nan when the OperatingSystemState
           is not BiosPost.
        5. Setting the sensor with PowerState="Always"
        6. The sensor always have the value.

Signed-off-by: ThuBaNguyen <thu@os.amperecomputing.com>

%% original patch: 0004-amperecpu-Support-label-_AddAssoc-option.patch
---
 include/ADCSensor.hpp       |   2 +-
 include/AmpereCPU.hpp       |   4 +-
 include/ExternalSensor.hpp  |   2 +-
 include/HwmonTempSensor.hpp |   2 +-
 include/PSUEvent.hpp        |   6 +-
 include/PSUSensor.hpp       |   2 +-
 include/TachSensor.hpp      |   2 +-
 include/Utils.hpp           |  90 ++++++++++++++------
 include/sensor.hpp          |  17 ++--
 src/ADCSensor.cpp           |   2 +-
 src/ADCSensorMain.cpp       |  31 ++++++-
 src/AmpereCPU.cpp           |   2 +-
 src/AmpereCPUMain.cpp       |  11 ++-
 src/ExitAirTempSensor.cpp   |   6 +-
 src/ExternalSensor.cpp      |   2 +-
 src/ExternalSensorMain.cpp  |  14 ++-
 src/FanMain.cpp             |  32 ++++++-
 src/HwmonTempMain.cpp       |  14 ++-
 src/HwmonTempSensor.cpp     |   2 +-
 src/IntelCPUSensor.cpp      |   6 +-
 src/IpmbSensor.cpp          |  17 +++-
 src/NVMeSensor.cpp          |   2 +-
 src/PSUEvent.cpp            |   4 +-
 src/PSUSensor.cpp           |   2 +-
 src/PSUSensorMain.cpp       |  25 +++++-
 src/TachSensor.cpp          |   2 +-
 src/Utils.cpp               | 165 +++++++++++-------------------------
 27 files changed, 276 insertions(+), 190 deletions(-)

diff --git a/include/ADCSensor.hpp b/include/ADCSensor.hpp
index 5c4b8ed..1c66bbe 100644
--- a/include/ADCSensor.hpp
+++ b/include/ADCSensor.hpp
@@ -70,7 +70,7 @@ class ADCSensor : public Sensor, public std::enable_shared_from_this<ADCSensor>
               std::shared_ptr<sdbusplus::asio::connection>& conn,
               boost::asio::io_service& io, const std::string& sensorName,
               std::vector<thresholds::Threshold>&& thresholds,
-              double scaleFactor, float pollRate, PowerState readState,
+              double scaleFactor, float pollRate, ReadState& readState,
               const std::string& sensorConfiguration,
               std::optional<BridgeGpio>&& bridgeGpio);
     ~ADCSensor() override;
diff --git a/include/AmpereCPU.hpp b/include/AmpereCPU.hpp
index c50db1c..5b8c9ec 100644
--- a/include/AmpereCPU.hpp
+++ b/include/AmpereCPU.hpp
@@ -23,7 +23,7 @@ class AmpereCPUSensor :
                     const std::string& sensorConfiguration,
                     std::string& sensorTypeName, double factor, double max,
                     double min, const std::string& label, size_t tSize,
-                    PowerState readState);
+                    const ReadState& readState);
     ~AmpereCPUSensor() override;
     void setupRead(void);
 
@@ -128,4 +128,4 @@ inline bool cpuPresence(const SensorData& sensorData)
     }
 
     return resp;
-}
\ No newline at end of file
+}
diff --git a/include/ExternalSensor.hpp b/include/ExternalSensor.hpp
index 20dd2f0..a7562d9 100644
--- a/include/ExternalSensor.hpp
+++ b/include/ExternalSensor.hpp
@@ -22,7 +22,7 @@ class ExternalSensor :
                    std::vector<thresholds::Threshold>&& thresholdsIn,
                    const std::string& sensorConfiguration, double maxReading,
                    double minReading, double timeoutSecs,
-                   const PowerState& powerState);
+                   const ReadState& powerState);
     ~ExternalSensor() override;
 
     // Call this immediately after calling the constructor
diff --git a/include/HwmonTempSensor.hpp b/include/HwmonTempSensor.hpp
index af275ec..f494441 100644
--- a/include/HwmonTempSensor.hpp
+++ b/include/HwmonTempSensor.hpp
@@ -30,7 +30,7 @@ class HwmonTempSensor :
                     std::vector<thresholds::Threshold>&& thresholds,
                     const struct SensorParams& thisSensorParameters,
                     float pollRate, const std::string& sensorConfiguration,
-                    PowerState powerState);
+                    const ReadState powerState);
     ~HwmonTempSensor() override;
     void setupRead(void);
 
diff --git a/include/PSUEvent.hpp b/include/PSUEvent.hpp
index 25a7ebc..f1a38de 100644
--- a/include/PSUEvent.hpp
+++ b/include/PSUEvent.hpp
@@ -35,7 +35,7 @@ class PSUSubEvent : public std::enable_shared_from_this<PSUSubEvent>
     PSUSubEvent(std::shared_ptr<sdbusplus::asio::dbus_interface> eventInterface,
                 const std::string& path,
                 std::shared_ptr<sdbusplus::asio::connection>& conn,
-                boost::asio::io_service& io, const PowerState& powerState,
+                boost::asio::io_service& io, const ReadState& readState,
                 const std::string& groupEventName, const std::string& eventName,
                 std::shared_ptr<std::set<std::string>> asserts,
                 std::shared_ptr<std::set<std::string>> combineEvent,
@@ -55,7 +55,7 @@ class PSUSubEvent : public std::enable_shared_from_this<PSUSubEvent>
     std::string path;
     std::string eventName;
 
-    PowerState readState;
+    ReadState readState;
     boost::asio::steady_timer waitTimer;
     std::shared_ptr<std::array<char, 128>> buffer;
     void restartRead();
@@ -81,7 +81,7 @@ class PSUCombineEvent
         sdbusplus::asio::object_server& objectServer,
         std::shared_ptr<sdbusplus::asio::connection>& conn,
         boost::asio::io_service& io, const std::string& psuName,
-        const PowerState& powerState,
+        const ReadState& powerState,
         boost::container::flat_map<std::string, std::vector<std::string>>&
             eventPathList,
         boost::container::flat_map<
diff --git a/include/PSUSensor.hpp b/include/PSUSensor.hpp
index 63699ea..00d35c7 100644
--- a/include/PSUSensor.hpp
+++ b/include/PSUSensor.hpp
@@ -20,7 +20,7 @@ class PSUSensor : public Sensor, public std::enable_shared_from_this<PSUSensor>
               boost::asio::io_service& io, const std::string& sensorName,
               std::vector<thresholds::Threshold>&& thresholds,
               const std::string& sensorConfiguration,
-              const PowerState& powerState, const std::string& sensorUnits,
+              const ReadState& powerState, const std::string& sensorUnits,
               unsigned int factor, double max, double min, double offset,
               const std::string& label, size_t tSize, double pollRate);
     ~PSUSensor() override;
diff --git a/include/TachSensor.hpp b/include/TachSensor.hpp
index c360395..dbbef24 100644
--- a/include/TachSensor.hpp
+++ b/include/TachSensor.hpp
@@ -72,7 +72,7 @@ class TachSensor :
                std::vector<thresholds::Threshold>&& thresholds,
                const std::string& sensorConfiguration,
                const std::pair<double, double>& limits,
-               const PowerState& powerState,
+               const ReadState& powerState,
                const std::optional<std::string>& led);
     ~TachSensor() override;
     void setupRead();
diff --git a/include/Utils.hpp b/include/Utils.hpp
index b39492e..57be555 100644
--- a/include/Utils.hpp
+++ b/include/Utils.hpp
@@ -65,12 +65,6 @@ bool findFiles(const std::filesystem::path& dirPath,
                std::string_view matchString,
                std::vector<std::filesystem::path>& foundPaths,
                int symlinkDepth = 1);
-bool isPowerOn(void);
-bool hasBiosPost(void);
-void setupPowerMatchCallback(
-    const std::shared_ptr<sdbusplus::asio::connection>& conn,
-    std::function<void(PowerState type, bool state)>&& callback);
-void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn);
 bool getSensorConfiguration(
     const std::string& type,
     const std::shared_ptr<sdbusplus::asio::connection>& dbusConnection,
@@ -106,7 +100,6 @@ constexpr const char* path = "/xyz/openbmc_project/object_mapper";
 constexpr const char* interface = "xyz.openbmc_project.ObjectMapper";
 constexpr const char* subtree = "GetSubTree";
 } // namespace mapper
-
 namespace properties
 {
 constexpr const char* interface = "org.freedesktop.DBus.Properties";
@@ -120,7 +113,10 @@ const static constexpr char* busname = "xyz.openbmc_project.State.Host";
 const static constexpr char* interface = "xyz.openbmc_project.State.Host";
 const static constexpr char* path = "/xyz/openbmc_project/state/host0";
 const static constexpr char* property = "CurrentHostState";
+const static constexpr char* sOn = ".Running";
+const static constexpr char* sAlways = "Always";
 } // namespace power
+
 namespace post
 {
 const static constexpr char* busname =
@@ -129,14 +125,53 @@ const static constexpr char* interface =
     "xyz.openbmc_project.State.OperatingSystem.Status";
 const static constexpr char* path = "/xyz/openbmc_project/state/os";
 const static constexpr char* property = "OperatingSystemState";
+const static constexpr char* sBiosPost = "BiosPost";
 } // namespace post
 
+namespace chassis
+{
+const static constexpr char* busname = "xyz.openbmc_project.State.Chassis";
+const static constexpr char* interface = "xyz.openbmc_project.State.Chassis";
+const static constexpr char* path = "/xyz/openbmc_project/state/chassis0";
+const static constexpr char* property = "CurrentPowerState";
+const static constexpr char* sOn = "On";
+} // namespace chassis
+
 namespace association
 {
 const static constexpr char* interface =
     "xyz.openbmc_project.Association.Definitions";
 } // namespace association
 
+class ReadState
+{
+  public:
+    ReadState(std::string busname = power::busname,
+              std::string path = power::path,
+              std::string intf = power::interface,
+              std::string prop = power::property,
+              std::string match = power::sAlways) :
+        busname(std::move(busname)),
+        path(std::move(path)), intf(std::move(intf)), prop(std::move(prop)),
+        match(std::move(match))
+    {}
+    ~ReadState() = default;
+    std::string busname;
+    std::string path;
+    std::string intf;
+    std::string prop;
+    std::string match;
+
+    std::string getKey(void)
+    {
+        return busname + path + intf + prop + match;
+    }
+};
+
+bool isReadStateMatch(ReadState readState);
+void setupStateMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn,
+                     ReadState readState);
+
 template <typename T>
 inline T loadVariant(const SensorBaseConfigMap& data, const std::string& key)
 {
@@ -164,34 +199,36 @@ inline T loadVariant(const SensorBaseConfigMap& data, const std::string& key)
     }
 }
 
-inline void setReadState(const std::string& str, PowerState& val)
+inline void setMatchString(const std::string& str, ReadState* val)
 {
-
-    if (str == "On")
+    if (!val)
     {
-        val = PowerState::on;
+        std::cerr << "Invalid ReadState option!" << std::endl;
+        return;
     }
-    else if (str == "BiosPost")
+    val->match = str;
+
+    return;
+}
+
+inline ReadState initReadState(PowerState state)
+{
+
+    if (state == PowerState::on)
     {
-        val = PowerState::biosPost;
+        return ReadState(power::busname, power::path, power::interface,
+                         power::property, power::sOn);
     }
-    else if (str == "Always")
+    else if (state == PowerState::biosPost)
     {
-        val = PowerState::always;
+        return ReadState(post::busname, post::path, post::interface,
+                         post::property, post::sBiosPost);
     }
-}
-
-inline PowerState getPowerState(const SensorBaseConfigMap& cfg)
-{
-    PowerState state = PowerState::always;
-    auto findPowerState = cfg.find("PowerState");
-    if (findPowerState != cfg.end())
+    else
     {
-        std::string powerState =
-            std::visit(VariantToStringVisitor(), findPowerState->second);
-        setReadState(powerState, state);
+        return ReadState(power::busname, power::path, power::interface,
+                         power::property, power::sAlways);
     }
-    return state;
 }
 
 inline void setLed(const std::shared_ptr<sdbusplus::asio::connection>& conn,
@@ -355,3 +392,4 @@ std::vector<std::unique_ptr<sdbusplus::bus::match_t>>
     setupPropertiesChangedMatches(
         sdbusplus::asio::connection& bus, std::span<const char* const> types,
         const std::function<void(sdbusplus::message_t&)>& handler);
+bool readingStateGood(ReadState readState);
diff --git a/include/sensor.hpp b/include/sensor.hpp
index 290b78b..f4dfdc2 100644
--- a/include/sensor.hpp
+++ b/include/sensor.hpp
@@ -61,7 +61,7 @@ struct Sensor
            const std::string& configurationPath, const std::string& objectType,
            bool isSettable, bool isMutable, const double max, const double min,
            std::shared_ptr<sdbusplus::asio::connection>& conn,
-           PowerState readState = PowerState::always) :
+           const ReadState& readState = initReadState(PowerState::always)) :
         name(sensor_paths::escapePathForDbus(name)),
         configurationPath(configurationPath),
         objectType(configInterfaceName(objectType)),
@@ -102,7 +102,7 @@ struct Sensor
     double hysteresisTrigger;
     double hysteresisPublish;
     std::shared_ptr<sdbusplus::asio::connection> dbusConnection;
-    PowerState readState;
+    ReadState readState;
     size_t errCount{0};
     std::unique_ptr<SensorInstrumentation> instrumentation;
 
@@ -252,9 +252,9 @@ struct Sensor
                               const std::string& label = std::string(),
                               size_t thresholdSize = 0)
     {
-        if (readState == PowerState::on || readState == PowerState::biosPost)
+        if (!std::empty(readState.match) && (readState.match != power::sAlways))
         {
-            setupPowerMatch(dbusConnection);
+            setupStateMatch(dbusConnection, readState);
         }
 
         createAssociation(association, configurationPath);
@@ -422,12 +422,9 @@ struct Sensor
 
     bool readingStateGood() const
     {
-        if (readState == PowerState::on && !isPowerOn())
-        {
-            return false;
-        }
-        if (readState == PowerState::biosPost &&
-            (!hasBiosPost() || !isPowerOn()))
+        /* Have read state match and read state don't match continue */
+        if (!std::empty(readState.match) &&
+            (readState.match != power::sAlways) && !isReadStateMatch(readState))
         {
             return false;
         }
diff --git a/src/ADCSensor.cpp b/src/ADCSensor.cpp
index fe2c8a7..2bc4c63 100644
--- a/src/ADCSensor.cpp
+++ b/src/ADCSensor.cpp
@@ -44,7 +44,7 @@ ADCSensor::ADCSensor(const std::string& path,
                      boost::asio::io_service& io, const std::string& sensorName,
                      std::vector<thresholds::Threshold>&& thresholdsIn,
                      const double scaleFactor, const float pollRate,
-                     PowerState readState,
+                     ReadState& readState,
                      const std::string& sensorConfiguration,
                      std::optional<BridgeGpio>&& bridgeGpio) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
diff --git a/src/ADCSensorMain.cpp b/src/ADCSensorMain.cpp
index 05d586f..f91220f 100644
--- a/src/ADCSensorMain.cpp
+++ b/src/ADCSensorMain.cpp
@@ -250,7 +250,36 @@ void createSensors(
                 }
             }
 
-            PowerState readState = getPowerState(baseConfiguration->second);
+            bool isMatchState = false;
+            auto findPowerOn = baseConfiguration->second.find("PowerState");
+            ReadState readState = initReadState(PowerState::always);
+            if (findPowerOn != baseConfiguration->second.end())
+            {
+                std::string powerState =
+                    std::visit(VariantToStringVisitor(), findPowerOn->second);
+                /* PowerState is "On" but match string is Running */
+                if (powerState == "On")
+                {
+                    powerState = power::sOn;
+                }
+                setMatchString(powerState, &readState);
+                isMatchState = true;
+            }
+            /* Only support one state match per sensor */
+            if (!isMatchState)
+            {
+                auto findChassisMatch =
+                    baseConfiguration->second.find("ChassisState");
+                if (findChassisMatch != baseConfiguration->second.end())
+                {
+                    std::string chassisState = std::visit(
+                        VariantToStringVisitor(), findChassisMatch->second);
+                    readState = ReadState(chassis::busname, chassis::path,
+                                          chassis::interface,
+                                          chassis::property, chassisState);
+                    isMatchState = true;
+                }
+            }
 
             auto& sensor = sensors[sensorName];
             sensor = nullptr;
diff --git a/src/AmpereCPU.cpp b/src/AmpereCPU.cpp
index 4dbfff8..fbbe909 100644
--- a/src/AmpereCPU.cpp
+++ b/src/AmpereCPU.cpp
@@ -46,7 +46,7 @@ AmpereCPUSensor::AmpereCPUSensor(
     std::vector<thresholds::Threshold>&& thresholdsIn,
     const std::string& sensorConfiguration, std::string& sensorTypeName,
     double factor, double max, double min, const std::string& label,
-    size_t tSize, PowerState readState) :
+    size_t tSize, const ReadState& readState) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
            objectType, false, false, max, min, conn, readState),
     objServer(objectServer),
diff --git a/src/AmpereCPUMain.cpp b/src/AmpereCPUMain.cpp
index 66be9db..58c56b7 100644
--- a/src/AmpereCPUMain.cpp
+++ b/src/AmpereCPUMain.cpp
@@ -142,7 +142,7 @@ static bool matchAndCreateSensor(
         baseConfig,
     const SensorData& sensorData, const std::string& interfacePath,
     const std::string& devType, const fs::path& sensorPath,
-    const std::vector<std::string>& findLabels, PowerState readState)
+    const std::vector<std::string>& findLabels, ReadState readState)
 {
     bool maxLabel = false;
     std::regex sensorNameRegEx("([A-Za-z]+)[0-9]*_");
@@ -438,12 +438,17 @@ static bool parseSensorConfig(
     }
 
     auto findPowerOn = baseConfig.second.find("PowerState");
-    PowerState readState = PowerState::always;
+    ReadState readState = initReadState(PowerState::always);
     if (findPowerOn != baseConfig.second.end())
     {
         std::string powerState =
             std::visit(VariantToStringVisitor(), findPowerOn->second);
-        setReadState(powerState, readState);
+        /* PowerState is "On" but match string is Running */
+        if (powerState == "On")
+        {
+            powerState = power::sOn;
+        }
+        setMatchString(powerState, &readState);
     }
 
     /* Find array of labels to be exposed if it is defined in config */
diff --git a/src/ExitAirTempSensor.cpp b/src/ExitAirTempSensor.cpp
index eb816e8..1f045a7 100644
--- a/src/ExitAirTempSensor.cpp
+++ b/src/ExitAirTempSensor.cpp
@@ -160,7 +160,7 @@ CFMSensor::CFMSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
                      std::shared_ptr<ExitAirTempSensor>& parent) :
     Sensor(escapeName(sensorName), std::move(thresholdData),
            sensorConfiguration, "CFMSensor", false, false, cfmMaxReading,
-           cfmMinReading, conn, PowerState::on),
+           cfmMinReading, conn, initReadState(PowerState::on)),
     parent(parent), objServer(objectServer)
 {
     sensorInterface = objectServer.add_interface(
@@ -497,7 +497,7 @@ ExitAirTempSensor::ExitAirTempSensor(
     std::vector<thresholds::Threshold>&& thresholdData) :
     Sensor(escapeName(sensorName), std::move(thresholdData),
            sensorConfiguration, "ExitAirTemp", false, false, exitAirMaxReading,
-           exitAirMinReading, conn, PowerState::on),
+           exitAirMinReading, conn, initReadState(PowerState::on)),
     objServer(objectServer)
 {
     sensorInterface = objectServer.add_interface(
@@ -709,7 +709,7 @@ bool ExitAirTempSensor::calculate(double& val)
     }
 
     // if fans are off, just make the exit temp equal to inlet
-    if (!isPowerOn())
+    if (!isReadStateMatch(readState))
     {
         val = inletTemp;
         return true;
diff --git a/src/ExternalSensor.cpp b/src/ExternalSensor.cpp
index cbba6e1..9eb3ba4 100644
--- a/src/ExternalSensor.cpp
+++ b/src/ExternalSensor.cpp
@@ -23,7 +23,7 @@ ExternalSensor::ExternalSensor(
     const std::string& sensorName, const std::string& sensorUnits,
     std::vector<thresholds::Threshold>&& thresholdsIn,
     const std::string& sensorConfiguration, double maxReading,
-    double minReading, double timeoutSecs, const PowerState& powerState) :
+    double minReading, double timeoutSecs, const ReadState& powerState) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
            objectType, true, true, maxReading, minReading, conn, powerState),
     objServer(objectServer), writeLast(std::chrono::steady_clock::now()),
diff --git a/src/ExternalSensorMain.cpp b/src/ExternalSensorMain.cpp
index 23721a8..e6e6ee7 100644
--- a/src/ExternalSensorMain.cpp
+++ b/src/ExternalSensorMain.cpp
@@ -305,7 +305,19 @@ void createSensors(
                           << "\n";
             }
 
-            PowerState readState = getPowerState(baseConfigMap);
+            auto findPowerOn = baseConfiguration.second.find("PowerState");
+            ReadState readState = initReadState(PowerState::always);
+            if (findPowerOn != baseConfiguration.second.end())
+            {
+                std::string powerState =
+                    std::visit(VariantToStringVisitor(), findPowerOn->second);
+                /* PowerState is "On" but match string is Running */
+                if (powerState == "On")
+                {
+                    powerState = power::sOn;
+                }
+                setMatchString(powerState, &readState);
+            }
 
             auto& sensorEntry = sensors[sensorName];
             sensorEntry = nullptr;
diff --git a/src/FanMain.cpp b/src/FanMain.cpp
index 9d495e0..cfdbc53 100644
--- a/src/FanMain.cpp
+++ b/src/FanMain.cpp
@@ -426,7 +426,37 @@ void createSensors(
                 redundancy = &systemRedundancy;
             }
 
-            PowerState powerState = getPowerState(baseConfiguration->second);
+            bool isMatchState = false;
+            ReadState powerState = initReadState(PowerState::on);
+            auto findPower = baseConfiguration->second.find("PowerState");
+            if (findPower != baseConfiguration->second.end())
+            {
+                std::string sPower =
+                     std::visit(VariantToStringVisitor(), findPower->second);
+                /* PowerState is "On" but match string is Running */
+                if (sPower == "On")
+                {
+                    sPower = power::sOn;
+                }
+                setMatchString(sPower, &powerState);
+                isMatchState = true;
+            }
+
+            /* Only support one state match per sensor */
+            if (!isMatchState)
+            {
+                auto findChassisMatch =
+                    baseConfiguration->second.find("ChassisState");
+                if (findChassisMatch != baseConfiguration->second.end())
+                {
+                    std::string chassisState = std::visit(
+                        VariantToStringVisitor(), findChassisMatch->second);
+                    powerState = ReadState(chassis::busname, chassis::path,
+                                           chassis::interface,
+                                           chassis::property, chassisState);
+                    isMatchState = true;
+                }
+            }
 
             constexpr double defaultMaxReading = 25000;
             constexpr double defaultMinReading = 0;
diff --git a/src/HwmonTempMain.cpp b/src/HwmonTempMain.cpp
index 9ebdfcd..3f964d6 100644
--- a/src/HwmonTempMain.cpp
+++ b/src/HwmonTempMain.cpp
@@ -397,7 +397,19 @@ void createSensors(
                 }
             }
 
-            PowerState readState = getPowerState(baseConfigMap);
+            auto findPowerOn = baseConfigMap.find("PowerState");
+            ReadState readState = initReadState(PowerState::always);
+            if (findPowerOn != baseConfigMap.end())
+            {
+                std::string powerState =
+                    std::visit(VariantToStringVisitor(), findPowerOn->second);
+                /* PowerState is "On" but match string is Running */
+                if (powerState == "On")
+                {
+                    powerState = power::sOn;
+                }
+                setMatchString(powerState, &readState);
+            }
 
             auto permitSet = getPermitSet(baseConfigMap);
             auto& sensor = sensors[sensorName];
diff --git a/src/HwmonTempSensor.cpp b/src/HwmonTempSensor.cpp
index ee096ea..02f3a9f 100644
--- a/src/HwmonTempSensor.cpp
+++ b/src/HwmonTempSensor.cpp
@@ -45,7 +45,7 @@ HwmonTempSensor::HwmonTempSensor(
     boost::asio::io_service& io, const std::string& sensorName,
     std::vector<thresholds::Threshold>&& thresholdsIn,
     const struct SensorParams& thisSensorParameters, const float pollRate,
-    const std::string& sensorConfiguration, const PowerState powerState) :
+    const std::string& sensorConfiguration, const ReadState powerState) :
     Sensor(boost::replace_all_copy(sensorName, " ", "_"),
            std::move(thresholdsIn), sensorConfiguration, objectType, false,
            false, thisSensorParameters.maxValue, thisSensorParameters.minValue,
diff --git a/src/IntelCPUSensor.cpp b/src/IntelCPUSensor.cpp
index 3410574..8047250 100644
--- a/src/IntelCPUSensor.cpp
+++ b/src/IntelCPUSensor.cpp
@@ -41,7 +41,7 @@ IntelCPUSensor::IntelCPUSensor(
     const std::string& sensorConfiguration, int cpuId, bool show,
     double dtsOffset) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
-           objectType, false, false, 0, 0, conn, PowerState::on),
+           objectType, false, false, 0, 0, conn, initReadState(PowerState::on)),
     objServer(objectServer), inputDev(io), waitTimer(io),
     nameTcontrol("Tcontrol CPU" + std::to_string(cpuId)), path(path),
     privTcontrol(std::numeric_limits<double>::quiet_NaN()),
@@ -88,7 +88,7 @@ IntelCPUSensor::IntelCPUSensor(
     }
 
     // call setup always as not all sensors call setInitialProperties
-    setupPowerMatch(conn);
+    setupStateMatch(conn, readState);
 }
 
 IntelCPUSensor::~IntelCPUSensor()
@@ -198,7 +198,7 @@ void IntelCPUSensor::updateMinMaxValues(void)
                 }
                 else
                 {
-                    if (isPowerOn())
+                    if (isReadStateMatch(readState))
                     {
                         updateProperty(sensorInterface, oldValue, 0, dbusName);
                     }
diff --git a/src/IpmbSensor.cpp b/src/IpmbSensor.cpp
index 5dabc25..d6eb592 100644
--- a/src/IpmbSensor.cpp
+++ b/src/IpmbSensor.cpp
@@ -64,7 +64,7 @@ IpmbSensor::IpmbSensor(std::shared_ptr<sdbusplus::asio::connection>& conn,
                        const float pollRate, std::string& sensorTypeName) :
     Sensor(escapeName(sensorName), std::move(thresholdData),
            sensorConfiguration, "IpmbSensor", false, false, ipmbMaxReading,
-           ipmbMinReading, conn, PowerState::on),
+           ipmbMinReading, conn, initReadState(PowerState::on)),
     deviceAddress(deviceAddress), hostSMbusIndex(hostSMbusIndex),
     sensorPollMs(static_cast<int>(pollRate * 1000)), objectServer(objectServer),
     waitTimer(io)
@@ -473,7 +473,20 @@ void IpmbSensor::parseConfigValues(const SensorBaseConfigMap& entry)
         offsetVal = std::visit(VariantToDoubleVisitor(), findOffsetVal->second);
     }
 
-    readState = getPowerState(entry);
+    auto findPowerState = entry.find("PowerState");
+
+    if (findPowerState != entry.end())
+    {
+        std::string powerState =
+            std::visit(VariantToStringVisitor(), findPowerState->second);
+
+        /* PowerState is "On" but match string is Running */
+        if (powerState == "On")
+        {
+            powerState = power::sOn;
+        }
+        setMatchString(powerState, &(readState));
+    }
 }
 
 void createSensors(
diff --git a/src/NVMeSensor.cpp b/src/NVMeSensor.cpp
index d32d166..278590a 100644
--- a/src/NVMeSensor.cpp
+++ b/src/NVMeSensor.cpp
@@ -30,7 +30,7 @@ NVMeSensor::NVMeSensor(sdbusplus::asio::object_server& objectServer,
                        const int busNumber) :
     Sensor(escapeName(sensorName), std::move(thresholdsIn), sensorConfiguration,
            NVMeSensor::sensorType, false, false, maxReading, minReading, conn,
-           PowerState::on),
+           initReadState(PowerState::on)),
     bus(busNumber), objServer(objectServer)
 {
     if (bus < 0)
diff --git a/src/PSUEvent.cpp b/src/PSUEvent.cpp
index 27bb8b1..cbcec99 100644
--- a/src/PSUEvent.cpp
+++ b/src/PSUEvent.cpp
@@ -35,7 +35,7 @@ PSUCombineEvent::PSUCombineEvent(
     sdbusplus::asio::object_server& objectServer,
     std::shared_ptr<sdbusplus::asio::connection>& conn,
     boost::asio::io_service& io, const std::string& psuName,
-    const PowerState& powerState,
+    const ReadState& powerState,
     boost::container::flat_map<std::string, std::vector<std::string>>&
         eventPathList,
     boost::container::flat_map<
@@ -138,7 +138,7 @@ static boost::container::flat_map<std::string,
 PSUSubEvent::PSUSubEvent(
     std::shared_ptr<sdbusplus::asio::dbus_interface> eventInterface,
     const std::string& path, std::shared_ptr<sdbusplus::asio::connection>& conn,
-    boost::asio::io_service& io, const PowerState& powerState,
+    boost::asio::io_service& io, const ReadState& powerState,
     const std::string& groupEventName, const std::string& eventName,
     std::shared_ptr<std::set<std::string>> asserts,
     std::shared_ptr<std::set<std::string>> combineEvent,
diff --git a/src/PSUSensor.cpp b/src/PSUSensor.cpp
index 6e2934f..8a1057b 100644
--- a/src/PSUSensor.cpp
+++ b/src/PSUSensor.cpp
@@ -40,7 +40,7 @@ PSUSensor::PSUSensor(const std::string& path, const std::string& objectType,
                      boost::asio::io_service& io, const std::string& sensorName,
                      std::vector<thresholds::Threshold>&& thresholdsIn,
                      const std::string& sensorConfiguration,
-                     const PowerState& powerState,
+                     const ReadState& powerState,
                      const std::string& sensorUnits, unsigned int factor,
                      double max, double min, double offset,
                      const std::string& label, size_t tSize, double pollRate) :
diff --git a/src/PSUSensorMain.cpp b/src/PSUSensorMain.cpp
index 918b9c6..4f90434 100644
--- a/src/PSUSensorMain.cpp
+++ b/src/PSUSensorMain.cpp
@@ -460,7 +460,19 @@ static void createSensorsCallback(
         checkGroupEvent(directory.string(), groupEventMatch,
                         groupEventPathList);
 
-        PowerState readState = getPowerState(*baseConfig);
+        auto findPowerOn = baseConfig->find("PowerState");
+        ReadState readState = initReadState(PowerState::always);
+        if (findPowerOn != baseConfig->end())
+        {
+            std::string powerState = std::visit(
+                VariantToStringVisitor(), findPowerOn->second);
+            /* PowerState is "On" but match string is Running */
+            if (powerState == "On")
+            {
+                powerState = power::sOn;
+            }
+            setMatchString(powerState, &readState);
+        }
 
         /* Check if there are more sensors in the same interface */
         int i = 1;
@@ -741,9 +753,14 @@ static void createSensorsCallback(
             auto findPowerState = baseConfig->find(keyPowerState);
             if (findPowerState != baseConfig->end())
             {
-                std::string powerState = std::visit(VariantToStringVisitor(),
-                                                    findPowerState->second);
-                setReadState(powerState, readState);
+                std::string powerState = std::visit(
+                   VariantToStringVisitor(), findPowerOn->second);
+                /* PowerState is "On" but match string is Running */
+                if (powerState == "On")
+                {
+                    powerState = power::sOn;
+                }
+                setMatchString(powerState, &readState);
             }
             if (!(psuProperty->minReading < psuProperty->maxReading))
             {
diff --git a/src/TachSensor.cpp b/src/TachSensor.cpp
index 35185cd..501b587 100644
--- a/src/TachSensor.cpp
+++ b/src/TachSensor.cpp
@@ -46,7 +46,7 @@ TachSensor::TachSensor(const std::string& path, const std::string& objectType,
                        std::vector<thresholds::Threshold>&& thresholdsIn,
                        const std::string& sensorConfiguration,
                        const std::pair<double, double>& limits,
-                       const PowerState& powerState,
+                       const ReadState& powerState,
                        const std::optional<std::string>& ledIn) :
     Sensor(escapeName(fanName), std::move(thresholdsIn), sensorConfiguration,
            objectType, false, false, limits.second, limits.first, conn,
diff --git a/src/Utils.cpp b/src/Utils.cpp
index 700b336..d331f6f 100644
--- a/src/Utils.cpp
+++ b/src/Utils.cpp
@@ -35,12 +35,12 @@
 
 namespace fs = std::filesystem;
 
-static bool powerStatusOn = false;
-static bool biosHasPost = false;
 static bool manufacturingMode = false;
 
-static std::unique_ptr<sdbusplus::bus::match_t> powerMatch = nullptr;
-static std::unique_ptr<sdbusplus::bus::match_t> postMatch = nullptr;
+boost::container::flat_map<std::string, bool> isStateMatch;
+boost::container::flat_map<std::string,
+                           std::unique_ptr<sdbusplus::bus::match::match>>
+    stateMatch;
 
 /**
  * return the contents of a file
@@ -285,31 +285,21 @@ bool findFiles(const fs::path& dirPath, std::string_view matchString,
     return true;
 }
 
-bool isPowerOn(void)
+bool isReadStateMatch(ReadState readState)
 {
-    if (!powerMatch)
+    std::string key = readState.getKey();
+    if (stateMatch.find(key) == stateMatch.end())
     {
         throw std::runtime_error("Power Match Not Created");
     }
-    return powerStatusOn;
+    return isStateMatch[key];
 }
 
-bool hasBiosPost(void)
+bool readingStateGood(ReadState readState)
 {
-    if (!postMatch)
-    {
-        throw std::runtime_error("Post Match Not Created");
-    }
-    return biosHasPost;
-}
-
-bool readingStateGood(const PowerState& powerState)
-{
-    if (powerState == PowerState::on && !isPowerOn())
-    {
-        return false;
-    }
-    if (powerState == PowerState::biosPost && (!hasBiosPost() || !isPowerOn()))
+    /* Have read state match and read state don't match continue */
+    if (!std::empty(readState.match) &&
+        (readState.match != power::sAlways) && !isReadStateMatch(readState))
     {
         return false;
     }
@@ -318,12 +308,15 @@ bool readingStateGood(const PowerState& powerState)
 }
 
 static void
-    getPowerStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn,
-                   size_t retries = 2)
+    getStateStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn,
+                   std::string busname, std::string path, std::string intf,
+                   std::string prop, std::string match, size_t retries = 2)
 {
     conn->async_method_call(
-        [conn, retries](boost::system::error_code ec,
-                        const std::variant<std::string>& state) {
+        [conn, retries, busname, path, intf, prop,
+         match](boost::system::error_code ec,
+                const std::variant<std::string>& state) {
+            std::string key = busname + path + intf + prop + match;
         if (ec)
         {
             if (retries != 0U)
@@ -331,10 +324,12 @@ static void
                 auto timer = std::make_shared<boost::asio::steady_timer>(
                     conn->get_io_context());
                 timer->expires_after(std::chrono::seconds(15));
-                timer->async_wait(
-                    [timer, conn, retries](boost::system::error_code) {
-                    getPowerStatus(conn, retries - 1);
-                });
+                timer->async_wait([timer, conn, retries, busname, path,
+                                       intf, prop,
+                                       match](boost::system::error_code) {
+                        getStateStatus(conn, busname, path, intf, prop, match,
+                                       retries - 1);
+                    });
                 return;
             }
 
@@ -343,84 +338,50 @@ static void
             std::cerr << "error getting power status " << ec.message() << "\n";
             return;
         }
-        powerStatusOn = std::get<std::string>(state).ends_with(".Running");
-        },
-        power::busname, power::path, properties::interface, properties::get,
-        power::interface, power::property);
-}
-
-static void
-    getPostStatus(const std::shared_ptr<sdbusplus::asio::connection>& conn,
-                  size_t retries = 2)
-{
-    conn->async_method_call(
-        [conn, retries](boost::system::error_code ec,
-                        const std::variant<std::string>& state) {
-        if (ec)
-        {
-            if (retries != 0U)
-            {
-                auto timer = std::make_shared<boost::asio::steady_timer>(
-                    conn->get_io_context());
-                timer->expires_after(std::chrono::seconds(15));
-                timer->async_wait(
-                    [timer, conn, retries](boost::system::error_code) {
-                    getPostStatus(conn, retries - 1);
-                });
-                return;
-            }
-            // we commonly come up before power control, we'll capture the
-            // property change later
-            std::cerr << "error getting post status " << ec.message() << "\n";
-            return;
-        }
-        const auto& value = std::get<std::string>(state);
-        biosHasPost = (value != "Inactive") &&
-                      (value != "xyz.openbmc_project.State.OperatingSystem."
-                                "Status.OSStatus.Inactive");
+        isStateMatch[key] =
+            std::get<std::string>(state).ends_with(match);
         },
-        post::busname, post::path, properties::interface, properties::get,
-        post::interface, post::property);
+        busname, path, properties::interface, properties::get, intf, prop);
 }
 
-void setupPowerMatchCallback(
-    const std::shared_ptr<sdbusplus::asio::connection>& conn,
-    std::function<void(PowerState type, bool state)>&& hostStatusCallback)
+void setupStateMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn,
+                     ReadState matchState)
 {
     static boost::asio::steady_timer timer(conn->get_io_context());
-    // create a match for powergood changes, first time do a method call to
+    std::string key = matchState.getKey();
+    std::string prop = matchState.prop;
+    std::string match = matchState.match;
+
+    // create a match for read state changes, first time do a method call to
     // cache the correct value
-    if (powerMatch)
+    if (stateMatch.find(key) != stateMatch.end())
     {
         return;
     }
 
-    powerMatch = std::make_unique<sdbusplus::bus::match_t>(
-        static_cast<sdbusplus::bus_t&>(*conn),
+    stateMatch[key] = std::make_unique<sdbusplus::bus::match::match>(
+        static_cast<sdbusplus::bus::bus&>(*conn),
         "type='signal',interface='" + std::string(properties::interface) +
-            "',path='" + std::string(power::path) + "',arg0='" +
-            std::string(power::interface) + "'",
-        [hostStatusCallback](sdbusplus::message_t& message) {
+            "',path='" + std::string(matchState.path) + "',arg0='" +
+            std::string(matchState.intf) + "'",
+        [prop, match, key](sdbusplus::message::message& message) {
         std::string objectName;
         boost::container::flat_map<std::string, std::variant<std::string>>
             values;
         message.read(objectName, values);
-        auto findState = values.find(power::property);
+        auto findState = values.find(prop);
         if (findState != values.end())
         {
-            bool on =
-                std::get<std::string>(findState->second).ends_with(".Running");
+            bool on = std::get<std::string>(findState->second).ends_with(match);
             if (!on)
             {
                 timer.cancel();
-                powerStatusOn = false;
-                hostStatusCallback(PowerState::on, powerStatusOn);
+                isStateMatch[key] = false;
                 return;
             }
             // on comes too quickly
             timer.expires_after(std::chrono::seconds(10));
-            timer.async_wait(
-                [hostStatusCallback](boost::system::error_code ec) {
+            timer.async_wait([key](boost::system::error_code ec) {
                 if (ec == boost::asio::error::operation_aborted)
                 {
                     return;
@@ -430,40 +391,12 @@ void setupPowerMatchCallback(
                     std::cerr << "Timer error " << ec.message() << "\n";
                     return;
                 }
-                powerStatusOn = true;
-                hostStatusCallback(PowerState::on, powerStatusOn);
+                isStateMatch[key] = true;
             });
         }
-        });
-
-    postMatch = std::make_unique<sdbusplus::bus::match_t>(
-        static_cast<sdbusplus::bus_t&>(*conn),
-        "type='signal',interface='" + std::string(properties::interface) +
-            "',path='" + std::string(post::path) + "',arg0='" +
-            std::string(post::interface) + "'",
-        [hostStatusCallback](sdbusplus::message_t& message) {
-        std::string objectName;
-        boost::container::flat_map<std::string, std::variant<std::string>>
-            values;
-        message.read(objectName, values);
-        auto findState = values.find(post::property);
-        if (findState != values.end())
-        {
-            auto& value = std::get<std::string>(findState->second);
-            biosHasPost = (value != "Inactive") &&
-                          (value != "xyz.openbmc_project.State.OperatingSystem."
-                                    "Status.OSStatus.Inactive");
-            hostStatusCallback(PowerState::biosPost, biosHasPost);
-        }
-        });
-
-    getPowerStatus(conn);
-    getPostStatus(conn);
-}
-
-void setupPowerMatch(const std::shared_ptr<sdbusplus::asio::connection>& conn)
-{
-    setupPowerMatchCallback(conn, [](PowerState, bool) {});
+    });
+    getStateStatus(conn, matchState.busname, matchState.path, matchState.intf,
+                   matchState.prop, matchState.match, 2);
 }
 
 // replaces limits if MinReading and MaxReading are found.
-- 
2.17.1

