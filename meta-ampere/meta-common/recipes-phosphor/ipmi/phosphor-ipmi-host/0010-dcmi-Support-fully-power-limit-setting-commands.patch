From 043b0c6119fef5f7a6ab20e450d88d7c39dad607 Mon Sep 17 00:00:00 2001
From: Thang Tran <thuutran@amperecomputing.com>
Date: Fri, 24 Mar 2023 16:58:12 +0700
Subject: [PATCH] dcmi: Support fully power limit setting commands

The correction time, sampling periodic and exception action of power
limit feature have been defined in the phosphor-dbus-interface. This
commit supports configuration power limit attributes via setting dbus
properties of Power.Cap interface.

Tested:
   1. Request to update attributes of power limit via ipmitool
      $ipmitool dcmi power set_limit <parameter> <value>
   2. Display configuration values as step 1.

Signed-off-by: Thang Tran <thuutran@amperecomputing.com>
Change-Id: I9dc69176782e10f00a5305696a139d740377d5be
---
 dcmihandler.cpp | 288 +++++++++++++++++++++++++++++++++++++++++++-----
 1 file changed, 262 insertions(+), 26 deletions(-)

diff --git a/dcmihandler.cpp b/dcmihandler.cpp
index f06441b..0ca241f 100644
--- a/dcmihandler.cpp
+++ b/dcmihandler.cpp
@@ -16,6 +16,7 @@
 #include <variant>
 #include <xyz/openbmc_project/Common/error.hpp>
 #include <xyz/openbmc_project/Network/EthernetInterface/server.hpp>
+#include <xyz/openbmc_project/Control/Power/Cap/server.hpp>
 
 using namespace phosphor::logging;
 using sdbusplus::xyz::openbmc_project::Network::server::EthernetInterface;
@@ -23,13 +24,17 @@ using sdbusplus::xyz::openbmc_project::Network::server::EthernetInterface;
 using InternalFailure =
     sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure;
 
+using PcapClass = sdbusplus::xyz::openbmc_project::Control::Power::server::Cap;
+
 void register_netfn_dcmi_functions() __attribute__((constructor));
 
-constexpr auto PCAP_PATH = "/xyz/openbmc_project/control/host0/power_cap";
-constexpr auto PCAP_INTERFACE = "xyz.openbmc_project.Control.Power.Cap";
+constexpr auto PCAP_INTERFACE = PcapClass::interface;
 
 constexpr auto POWER_CAP_PROP = "PowerCap";
 constexpr auto POWER_CAP_ENABLE_PROP = "PowerCapEnable";
+constexpr auto POWER_CAP_EXCEPT_ACT_PROP = "ExceptionAction";
+constexpr auto POWER_CAP_SAMPL_PERIOD_PROP = "SamplingPeriod";
+constexpr auto POWER_CAP_CORRECT_TIME_PROP = "CorrectionTime";
 
 constexpr auto DCMI_PARAMETER_REVISION = 2;
 constexpr auto DCMI_SPEC_MAJOR_VERSION = 1;
@@ -74,10 +79,10 @@ bool isDCMIPowerMgmtSupported()
 
 uint32_t getPcap(sdbusplus::bus_t& bus)
 {
-    auto settingService = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
 
-    auto method = bus.new_method_call(settingService.c_str(), PCAP_PATH,
-                                      "org.freedesktop.DBus.Properties", "Get");
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Get");
 
     method.append(PCAP_INTERFACE, POWER_CAP_PROP);
     auto reply = bus.call(method);
@@ -95,10 +100,10 @@ uint32_t getPcap(sdbusplus::bus_t& bus)
 
 bool getPcapEnabled(sdbusplus::bus_t& bus)
 {
-    auto settingService = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
 
-    auto method = bus.new_method_call(settingService.c_str(), PCAP_PATH,
-                                      "org.freedesktop.DBus.Properties", "Get");
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Get");
 
     method.append(PCAP_INTERFACE, POWER_CAP_ENABLE_PROP);
     auto reply = bus.call(method);
@@ -114,12 +119,111 @@ bool getPcapEnabled(sdbusplus::bus_t& bus)
     return std::get<bool>(pcapEnabled);
 }
 
+PcapClass::ExceptionActions getPcapExceptAction(sdbusplus::bus_t& bus)
+{
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
+
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Get");
+
+    method.append(PCAP_INTERFACE, POWER_CAP_EXCEPT_ACT_PROP);
+    auto reply = bus.call(method);
+
+    if (reply.is_method_error())
+    {
+        log<level::ERR>("Error in getPcapExceptAction prop");
+        elog<InternalFailure>();
+    }
+    std::variant<std::string> pcapExceptActionStr;
+    PcapClass::ExceptionActions exceptAct;
+    
+    reply.read(pcapExceptActionStr);
+
+    try
+    {
+        exceptAct =
+            PcapClass::convertExceptionActionsFromString(
+                            std::get<std::string>(pcapExceptActionStr));
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        log<level::ERR>("Error in Convert Exception Action");
+        elog<InternalFailure>();
+    }
+
+    return exceptAct;
+}
+
+uint32_t getPcapCorrectTime(sdbusplus::bus_t& bus)
+{
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
+
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Get");
+
+    method.append(PCAP_INTERFACE, POWER_CAP_CORRECT_TIME_PROP);
+    auto reply = bus.call(method);
+
+    if (reply.is_method_error())
+    {
+        log<level::ERR>("Error in getPcapCorrectTime prop");
+        elog<InternalFailure>();
+    }
+    std::variant<uint64_t> pcapCorrectTimeUs;
+    uint32_t pcapCorrectTimeMs;
+
+    reply.read(pcapCorrectTimeUs);
+
+    /*
+     * Dbus is storing Correction time in microseconds unit.
+     * Therefore, we have to convert it to milliseconds.
+     */
+    pcapCorrectTimeMs = 
+        (uint32_t)(std::chrono::duration_cast<std::chrono::milliseconds>(
+                    std::chrono::microseconds(
+                        std::get<uint64_t>(pcapCorrectTimeUs)))).count();
+                            
+    return pcapCorrectTimeMs;
+}
+
+uint16_t getPcapSamplPeriod(sdbusplus::bus_t& bus)
+{
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
+
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Get");
+
+    method.append(PCAP_INTERFACE, POWER_CAP_SAMPL_PERIOD_PROP);
+    auto reply = bus.call(method);
+
+    if (reply.is_method_error())
+    {
+        log<level::ERR>("Error in getPcapSamplPeriod prop");
+        elog<InternalFailure>();
+    }
+    std::variant<uint64_t> pcapSamplPeriodUs;
+    uint16_t pcapSamplPeriodSecond;
+
+    reply.read(pcapSamplPeriodUs);
+
+    /*
+     * Dbus is storing Sampling periodic in microseconds unit.
+     * Therefore, we have to convert it to seconds.
+     */
+    pcapSamplPeriodSecond = 
+        (uint16_t)(std::chrono::duration_cast<std::chrono::seconds>(
+                    std::chrono::microseconds(
+                        std::get<uint64_t>(pcapSamplPeriodUs)))).count();
+
+    return pcapSamplPeriodSecond;
+}
+
 void setPcap(sdbusplus::bus_t& bus, const uint32_t powerCap)
 {
-    auto service = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
 
-    auto method = bus.new_method_call(service.c_str(), PCAP_PATH,
-                                      "org.freedesktop.DBus.Properties", "Set");
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Set");
 
     method.append(PCAP_INTERFACE, POWER_CAP_PROP);
     method.append(std::variant<uint32_t>(powerCap));
@@ -135,10 +239,10 @@ void setPcap(sdbusplus::bus_t& bus, const uint32_t powerCap)
 
 void setPcapEnable(sdbusplus::bus_t& bus, bool enabled)
 {
-    auto service = ipmi::getService(bus, PCAP_INTERFACE, PCAP_PATH);
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
 
-    auto method = bus.new_method_call(service.c_str(), PCAP_PATH,
-                                      "org.freedesktop.DBus.Properties", "Set");
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Set");
 
     method.append(PCAP_INTERFACE, POWER_CAP_ENABLE_PROP);
     method.append(std::variant<bool>(enabled));
@@ -152,6 +256,80 @@ void setPcapEnable(sdbusplus::bus_t& bus, bool enabled)
     }
 }
 
+void setPcapExceptAction(sdbusplus::bus_t& bus,
+                        PcapClass::ExceptionActions pcapExceptAct)
+{
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
+
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Set");
+    std::string pcapExceptActStr =
+                    PcapClass::convertExceptionActionsToString(pcapExceptAct);
+
+    method.append(PCAP_INTERFACE, POWER_CAP_EXCEPT_ACT_PROP);
+    method.append(std::variant<std::string>(pcapExceptActStr));
+
+    auto reply = bus.call(method);
+
+    if (reply.is_method_error())
+    {
+        log<level::ERR>("Error in setPcapExceptAction property");
+        elog<InternalFailure>();
+    }
+}
+
+void setPcapCorrectTime(sdbusplus::bus_t& bus, uint32_t pcapCorrectTime)
+{
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
+
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Set");
+    /*
+     * Dbus is storing Correction time in microseconds unit.
+     * Therefore, we have to convert it to microseconds.
+     */
+    uint64_t pcapCorrectTimeUs = 
+            (uint64_t)(std::chrono::duration_cast<std::chrono::microseconds>(
+                    std::chrono::milliseconds(pcapCorrectTime))).count();
+
+    method.append(PCAP_INTERFACE, POWER_CAP_CORRECT_TIME_PROP);
+    method.append(std::variant<uint64_t>(pcapCorrectTimeUs));
+
+    auto reply = bus.call(method);
+
+    if (reply.is_method_error())
+    {
+        log<level::ERR>("Error in setPcapCorrectTime property");
+        elog<InternalFailure>();
+    }
+}
+
+void setPcapSamplPeriod(sdbusplus::bus_t& bus, uint16_t pcapSamplPeriod)
+{
+    auto pcapObject = ipmi::getDbusObject(bus, PCAP_INTERFACE);
+
+    auto method = bus.new_method_call(pcapObject.second.c_str(),
+            pcapObject.first.c_str(), "org.freedesktop.DBus.Properties", "Set");
+    /*
+     * Dbus is storing Sampling periodic in microseconds unit.
+     * Therefore, we have to convert it to microseconds unit.
+     */
+    uint64_t pcapSamplPeriodUs = 
+            (uint64_t)(std::chrono::duration_cast<std::chrono::microseconds>(
+                    std::chrono::seconds(pcapSamplPeriod))).count();
+
+    method.append(PCAP_INTERFACE, POWER_CAP_SAMPL_PERIOD_PROP);
+    method.append(std::variant<uint64_t>(pcapSamplPeriodUs));
+
+    auto reply = bus.call(method);
+
+    if (reply.is_method_error())
+    {
+        log<level::ERR>("Error in setPcapSamplPeriod property");
+        elog<InternalFailure>();
+    }
+}
+
 void readAssetTagObjectTree(dcmi::assettag::ObjectTree& objectTree)
 {
     static constexpr auto mapperBusName = "xyz.openbmc_project.ObjectMapper";
@@ -320,11 +498,17 @@ ipmi_ret_t getPowerLimit(ipmi_netfn_t, ipmi_cmd_t, ipmi_request_t,
     sdbusplus::bus_t sdbus{ipmid_get_sd_bus_connection()};
     uint32_t pcapValue = 0;
     bool pcapEnable = false;
+    uint32_t pcapCorrectTime = 0;
+    uint16_t pcapSamplPeriod = 0;
+    PcapClass::ExceptionActions pcapExceptAct;
 
     try
     {
         pcapValue = dcmi::getPcap(sdbus);
         pcapEnable = dcmi::getPcapEnabled(sdbus);
+        pcapCorrectTime = dcmi::getPcapCorrectTime(sdbus);
+        pcapSamplPeriod = dcmi::getPcapSamplPeriod(sdbus);
+        pcapExceptAct = dcmi::getPcapExceptAction(sdbus);
     }
     catch (const InternalFailure& e)
     {
@@ -332,20 +516,33 @@ ipmi_ret_t getPowerLimit(ipmi_netfn_t, ipmi_cmd_t, ipmi_request_t,
         return IPMI_CC_UNSPECIFIED_ERROR;
     }
 
-    /*
-     * Exception action if power limit is exceeded and cannot be controlled
-     * with the correction time limit is hardcoded to Hard Power Off system
-     * and log event to SEL.
-     */
-    constexpr auto exception = 0x01;
-    responseData->exceptionAction = exception;
+    switch(pcapExceptAct)
+    {
+        case PcapClass::ExceptionActions::NoAction:
+        {
+            responseData->exceptionAction = 0x00;
+            break;
+        }
+        case PcapClass::ExceptionActions::HardPowerOff:
+        {
+            responseData->exceptionAction = 0x01;
+            break;
+        }
+        case PcapClass::ExceptionActions::LogEventOnly:
+        {
+            responseData->exceptionAction = 0x11;
+            break;
+        }
+        case PcapClass::ExceptionActions::Oem:
+        {
+            responseData->exceptionAction = 0x02;
+            break;
+        }
+    }
 
     responseData->powerLimit = static_cast<uint16_t>(pcapValue);
-
-    /*
-     * Correction time limit and Statistics sampling period is currently not
-     * populated.
-     */
+    responseData->correctionTime = pcapCorrectTime;
+    responseData->samplingPeriod = pcapSamplPeriod;
 
     *data_len = outPayload.size();
     memcpy(response, outPayload.data(), *data_len);
@@ -377,9 +574,48 @@ ipmi_ret_t setPowerLimit(ipmi_netfn_t, ipmi_cmd_t, ipmi_request_t request,
     sdbusplus::bus_t sdbus{ipmid_get_sd_bus_connection()};
 
     // Only process the power limit requested in watts.
+    // ThangTH: TODO
     try
     {
+        std::optional<PcapClass::ExceptionActions> pcapExceptAct = std::nullopt;
         dcmi::setPcap(sdbus, requestData->powerLimit);
+        dcmi::setPcapCorrectTime(sdbus, requestData->correctionTime);
+        dcmi::setPcapSamplPeriod(sdbus, requestData->samplingPeriod);
+
+        /*
+         * As defined in table 6-18 of DCMI specification version 1.5.
+         * The Exception action value is mapped as below
+         *  00h - No Action
+         *  01h - Hard Power Off system and log events to SEL
+         *  02h - 10h OEM defined actions
+         *  11h - Log event to SEL only
+         *  12h-FFh Reserved
+         */
+        if (requestData->exceptionAction == 0x00)
+        {
+            pcapExceptAct = PcapClass::ExceptionActions::NoAction;                
+        }
+        else if (requestData->exceptionAction == 0x01)
+        {
+            pcapExceptAct = PcapClass::ExceptionActions::HardPowerOff;
+        }
+        else if (requestData->exceptionAction == 0x11)
+        {
+            pcapExceptAct = PcapClass::ExceptionActions::LogEventOnly;
+        }
+        else if (requestData->exceptionAction <= 0x10)
+        {
+            pcapExceptAct = PcapClass::ExceptionActions::Oem; 
+        }
+        else
+        {
+            // pcapExceptAct = std::nullopt;
+        }
+
+        if (pcapExceptAct != std::nullopt)
+        {
+            dcmi::setPcapExceptAction(sdbus, pcapExceptAct.value());
+        }
     }
     catch (const InternalFailure& e)
     {
-- 
2.25.1

