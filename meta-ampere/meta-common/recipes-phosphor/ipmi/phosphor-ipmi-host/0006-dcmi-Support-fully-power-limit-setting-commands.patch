From 7b44fe1c45a926ef65f909fe135b42aac2b5cc94 Mon Sep 17 00:00:00 2001
From: Thang Tran <thuutran@amperecomputing.com>
Date: Tue, 19 Sep 2023 10:58:53 +0700
Subject: [PATCH 6/6] dcmi: Support fully power limit setting commands

The correction time, sampling periodic and exception action of power
limit feature have been defined in the phosphor-dbus-interface. This
commit supports configuration power limit attributes via setting dbus
properties of Power.Cap interface.

Tested:
   1. Request to update attributes of power limit via ipmitool
      $ipmitool dcmi power set_limit <parameter> <value>
   2. Display configuration values as step 1.

Change-Id: Icfe33e1021b77b098cb6662b524daed02d666f0c
Signed-off-by: Thang Tran <thuutran@amperecomputing.com>
---
 dcmihandler.cpp | 392 +++++++++++++++++++++++++++++++++++++++++-------
 1 file changed, 340 insertions(+), 52 deletions(-)

diff --git a/dcmihandler.cpp b/dcmihandler.cpp
index 135c745..e10d0cd 100644
--- a/dcmihandler.cpp
+++ b/dcmihandler.cpp
@@ -11,6 +11,7 @@
 #include <phosphor-logging/log.hpp>
 #include <sdbusplus/bus.hpp>
 #include <xyz/openbmc_project/Common/error.hpp>
+#include <xyz/openbmc_project/Control/Power/Cap/server.hpp>
 #include <xyz/openbmc_project/Network/EthernetInterface/server.hpp>
 
 #include <bitset>
@@ -20,17 +21,20 @@
 
 using namespace phosphor::logging;
 using sdbusplus::xyz::openbmc_project::Network::server::EthernetInterface;
+using PcapClass = sdbusplus::xyz::openbmc_project::Control::Power::server::Cap;
 
 using InternalFailure =
     sdbusplus::xyz::openbmc_project::Common::Error::InternalFailure;
 
 void register_netfn_dcmi_functions() __attribute__((constructor));
 
-constexpr auto pcapPath = "/xyz/openbmc_project/control/host0/power_cap";
-constexpr auto pcapInterface = "xyz.openbmc_project.Control.Power.Cap";
+constexpr auto pcapInterface = PcapClass::interface;
 
 constexpr auto powerCapProp = "PowerCap";
 constexpr auto powerCapEnableProp = "PowerCapEnable";
+constexpr auto powerCapExceptActProp = "ExceptionAction";
+constexpr auto powerCapSamplPeriodProp = "SamplingPeriod";
+constexpr auto powerCapCorrectTimeProp = "CorrectionTime";
 
 using namespace phosphor::logging;
 
@@ -104,18 +108,41 @@ bool isDCMIPowerMgmtSupported()
     return supported;
 }
 
-std::optional<uint32_t> getPcap(ipmi::Context::ptr& ctx)
+std::optional<ipmi::DbusObjectInfo> getPCapObject(ipmi::Context::ptr& ctx)
 {
-    std::string service{};
-    boost::system::error_code ec = ipmi::getService(ctx, pcapInterface,
-                                                    pcapPath, service);
+    static std::optional<ipmi::DbusObjectInfo> pcapObject = std::nullopt;
+
+    if (pcapObject != std::nullopt)
+    {
+        return pcapObject;
+    }
+
+    ipmi::DbusObjectInfo objectPath{};
+    boost::system::error_code ec = ipmi::getDbusObject(ctx, pcapInterface,
+                                                       objectPath);
     if (ec.value())
     {
         return std::nullopt;
     }
+
+    pcapObject = objectPath;
+
+    return pcapObject;
+}
+
+std::optional<uint32_t> getPcap(ipmi::Context::ptr& ctx)
+{
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
+    {
+        return std::nullopt;
+    }
+
     uint32_t pcap{};
-    ec = ipmi::getDbusProperty(ctx, service, pcapPath, pcapInterface,
-                               powerCapProp, pcap);
+    boost::system::error_code ec = ipmi::getDbusProperty(
+        ctx, pcapObject.value().second.c_str(),
+        pcapObject.value().first.c_str(), pcapInterface, powerCapProp, pcap);
     if (ec.value())
     {
         log<level::ERR>("Error in getPcap prop",
@@ -123,21 +150,24 @@ std::optional<uint32_t> getPcap(ipmi::Context::ptr& ctx)
         elog<InternalFailure>();
         return std::nullopt;
     }
+
     return pcap;
 }
 
 std::optional<bool> getPcapEnabled(ipmi::Context::ptr& ctx)
 {
-    std::string service{};
-    boost::system::error_code ec = ipmi::getService(ctx, pcapInterface,
-                                                    pcapPath, service);
-    if (ec.value())
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
     {
         return std::nullopt;
     }
+
     bool pcapEnabled{};
-    ec = ipmi::getDbusProperty(ctx, service, pcapPath, pcapInterface,
-                               powerCapEnableProp, pcapEnabled);
+    boost::system::error_code ec =
+        ipmi::getDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapEnableProp, pcapEnabled);
     if (ec.value())
     {
         log<level::ERR>("Error in getPcap prop");
@@ -147,18 +177,111 @@ std::optional<bool> getPcapEnabled(ipmi::Context::ptr& ctx)
     return pcapEnabled;
 }
 
-bool setPcap(ipmi::Context::ptr& ctx, const uint32_t powerCap)
+std::optional<PcapClass::ExceptionActions>
+    getPcapExceptAction(ipmi::Context::ptr& ctx)
 {
-    std::string service{};
-    boost::system::error_code ec = ipmi::getService(ctx, pcapInterface,
-                                                    pcapPath, service);
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
+    {
+        return std::nullopt;
+    }
+
+    std::string exceptActStr{};
+
+    boost::system::error_code ec =
+        ipmi::getDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapExceptActProp, exceptActStr);
+
     if (ec.value())
+    {
+        log<level::ERR>("Error in getPcap prop",
+                        entry("ERROR=%s", ec.message().c_str()));
+        elog<InternalFailure>();
+        return std::nullopt;
+    }
+
+    PcapClass::ExceptionActions exceptAct{};
+    try
+    {
+        exceptAct = PcapClass::convertExceptionActionsFromString(exceptActStr);
+    }
+    catch (const sdbusplus::exception_t& e)
+    {
+        log<level::ERR>("Error in Converting Exception Action");
+        elog<InternalFailure>();
+        return std::nullopt;
+    }
+
+    return exceptAct;
+}
+
+std::optional<uint32_t> getPcapCorrectTime(ipmi::Context::ptr& ctx)
+{
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
+    {
+        return std::nullopt;
+    }
+
+    uint64_t pcapCorrectTimeUs{};
+    boost::system::error_code ec =
+        ipmi::getDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapCorrectTimeProp, pcapCorrectTimeUs);
+    if (ec.value())
+    {
+        log<level::ERR>("Error in getPcap prop");
+        elog<InternalFailure>();
+        return std::nullopt;
+    }
+
+    return (uint32_t)(std::chrono::duration_cast<std::chrono::milliseconds>(
+                          std::chrono::microseconds(pcapCorrectTimeUs)))
+        .count();
+}
+
+std::optional<uint16_t> getPcapSamplPeriod(ipmi::Context::ptr& ctx)
+{
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
+    {
+        return std::nullopt;
+    }
+
+    uint64_t pcapSamplPeriodUs{};
+    boost::system::error_code ec =
+        ipmi::getDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapSamplPeriodProp, pcapSamplPeriodUs);
+    if (ec.value())
+    {
+        log<level::ERR>("Error in getPcap prop");
+        elog<InternalFailure>();
+        return std::nullopt;
+    }
+
+    return (uint16_t)(std::chrono::duration_cast<std::chrono::seconds>(
+                          std::chrono::microseconds(pcapSamplPeriodUs)))
+        .count();
+}
+
+bool setPcap(ipmi::Context::ptr& ctx, const uint32_t powerCap)
+{
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
     {
         return false;
     }
 
-    ec = ipmi::setDbusProperty(ctx, service, pcapPath, pcapInterface,
-                               powerCapProp, powerCap);
+    boost::system::error_code ec =
+        ipmi::setDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapProp, powerCap);
     if (ec.value())
     {
         log<level::ERR>("Error in setPcap property",
@@ -171,16 +294,17 @@ bool setPcap(ipmi::Context::ptr& ctx, const uint32_t powerCap)
 
 bool setPcapEnable(ipmi::Context::ptr& ctx, bool enabled)
 {
-    std::string service{};
-    boost::system::error_code ec = ipmi::getService(ctx, pcapInterface,
-                                                    pcapPath, service);
-    if (ec.value())
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
     {
         return false;
     }
 
-    ec = ipmi::setDbusProperty(ctx, service, pcapPath, pcapInterface,
-                               powerCapEnableProp, enabled);
+    boost::system::error_code ec =
+        ipmi::setDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapEnableProp, enabled);
     if (ec.value())
     {
         log<level::ERR>("Error in setPcapEnabled property",
@@ -191,6 +315,97 @@ bool setPcapEnable(ipmi::Context::ptr& ctx, bool enabled)
     return true;
 }
 
+bool setPcapExceptAction(ipmi::Context::ptr& ctx,
+                         PcapClass::ExceptionActions pcapExceptAct)
+{
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
+    {
+        return false;
+    }
+
+    std::string pcapExceptActStr =
+        PcapClass::convertExceptionActionsToString(pcapExceptAct);
+    boost::system::error_code ec =
+        ipmi::setDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapExceptActProp, pcapExceptActStr);
+    if (ec.value())
+    {
+        log<level::ERR>("Error in setPcap property",
+                        entry("ERROR=%s", ec.message().c_str()));
+        elog<InternalFailure>();
+        return false;
+    }
+
+    return true;
+}
+
+bool setPcapCorrectTime(ipmi::Context::ptr& ctx, uint32_t pcapCorrectTime)
+{
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
+    {
+        return false;
+    }
+
+    /*
+     * Dbus is storing Correction time in microseconds unit.
+     * Therefore, we have to convert it from milisecond to microseconds.
+     */
+    uint64_t pcapCorrectTimeUs =
+        (uint64_t)(std::chrono::duration_cast<std::chrono::microseconds>(
+                       std::chrono::milliseconds(pcapCorrectTime)))
+            .count();
+    boost::system::error_code ec =
+        ipmi::setDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapCorrectTimeProp, pcapCorrectTimeUs);
+    if (ec.value())
+    {
+        log<level::ERR>("Error in setPcap property",
+                        entry("ERROR=%s", ec.message().c_str()));
+        elog<InternalFailure>();
+        return false;
+    }
+
+    return true;
+}
+
+bool setPcapSamplPeriod(ipmi::Context::ptr& ctx, uint16_t pcapSamplPeriod)
+{
+    std::optional<ipmi::DbusObjectInfo> pcapObject = getPCapObject(ctx);
+
+    if (pcapObject == std::nullopt)
+    {
+        return false;
+    }
+
+    /*
+     * Dbus is storing Sampling periodic in microseconds unit.
+     * Therefore, we have to convert it from seconds to microseconds unit.
+     */
+    uint64_t pcapSamplPeriodUs =
+        (uint64_t)(std::chrono::duration_cast<std::chrono::microseconds>(
+                       std::chrono::seconds(pcapSamplPeriod)))
+            .count();
+    boost::system::error_code ec =
+        ipmi::setDbusProperty(ctx, pcapObject.value().second.c_str(),
+                              pcapObject.value().first.c_str(), pcapInterface,
+                              powerCapSamplPeriodProp, pcapSamplPeriodUs);
+    if (ec.value())
+    {
+        log<level::ERR>("Error in setPcap property",
+                        entry("ERROR=%s", ec.message().c_str()));
+        elog<InternalFailure>();
+        return false;
+    }
+
+    return true;
+}
+
 std::optional<std::string> readAssetTag(ipmi::Context::ptr& ctx)
 {
     // Read the object tree with the inventory root to figure out the object
@@ -327,7 +542,11 @@ bool setDHCPOption(ipmi::Context::ptr& ctx, std::string prop, bool value)
 
 } // namespace dcmi
 
+constexpr uint8_t exceptionNoAction = 0x00;
 constexpr uint8_t exceptionPowerOff = 0x01;
+constexpr uint8_t exceptionLogEventOnly = 0x11;
+constexpr uint8_t exceptionOem = 0x02;
+
 ipmi::RspType<uint16_t, // reserved
               uint8_t,  // exception actions
               uint16_t, // power limit requested in watts
@@ -348,39 +567,62 @@ ipmi::RspType<uint16_t, // reserved
 
     std::optional<uint16_t> pcapValue = dcmi::getPcap(ctx);
     std::optional<bool> pcapEnable = dcmi::getPcapEnabled(ctx);
-    if (!pcapValue || !pcapEnable)
+    std::optional<uint32_t> pcapCorrectTime = dcmi::getPcapCorrectTime(ctx);
+    std::optional<uint16_t> pcapSamplPeriod = dcmi::getPcapSamplPeriod(ctx);
+    std::optional<PcapClass::ExceptionActions> pcapExceptAct =
+        dcmi::getPcapExceptAction(ctx);
+
+    if (!pcapValue || !pcapEnable || !pcapCorrectTime || !pcapSamplPeriod ||
+        !pcapExceptAct)
     {
         return ipmi::responseUnspecifiedError();
     }
 
     constexpr uint16_t reserved1{};
     constexpr uint16_t reserved2{};
-    /*
-     * Exception action if power limit is exceeded and cannot be controlled
-     * with the correction time limit is hardcoded to Hard Power Off system
-     * and log event to SEL.
-     */
-    constexpr uint8_t exception = exceptionPowerOff;
-    /*
-     * Correction time limit and Statistics sampling period is currently not
-     * populated.
-     */
-    constexpr uint32_t correctionTime{};
-    constexpr uint16_t statsPeriod{};
-    if (!pcapEnable)
+    uint8_t exception = exceptionPowerOff;
+    switch (pcapExceptAct.value())
+    {
+        case PcapClass::ExceptionActions::NoAction:
+        {
+            exception = exceptionNoAction;
+            break;
+        }
+        case PcapClass::ExceptionActions::HardPowerOff:
+        {
+            exception = exceptionPowerOff;
+            break;
+        }
+        case PcapClass::ExceptionActions::LogEventOnly:
+        {
+            exception = exceptionLogEventOnly;
+            break;
+        }
+        case PcapClass::ExceptionActions::Oem:
+        {
+            exception = exceptionOem;
+            break;
+        }
+    }
+
+    if (!pcapEnable.value())
     {
         constexpr ipmi::Cc responseNoPowerLimitSet = 0x80;
-        constexpr uint16_t noPcap{};
         return ipmi::response(responseNoPowerLimitSet, reserved1, exception,
-                              noPcap, correctionTime, reserved2, statsPeriod);
+                              pcapValue.value(), pcapCorrectTime.value(),
+                              reserved2, pcapSamplPeriod.value());
     }
-    return ipmi::responseSuccess(reserved1, exception, *pcapValue,
-                                 correctionTime, reserved2, statsPeriod);
+    return ipmi::responseSuccess(reserved1, exception, pcapValue.value(),
+                                 pcapCorrectTime.value(), reserved2,
+                                 pcapSamplPeriod.value());
 }
 
-ipmi::RspType<> setPowerLimit(ipmi::Context::ptr& ctx, uint16_t reserved1,
+ipmi::RspType<> setPowerLimit(ipmi::Context::ptr& ctx,
+                              [[maybe_unused]] uint16_t reserved1,
+                              [[maybe_unused]] uint8_t reserved2,
                               uint8_t exceptionAction, uint16_t powerLimit,
-                              uint32_t correctionTime, uint16_t reserved2,
+                              uint32_t correctionTime,
+                              [[maybe_unused]] uint16_t reserved3,
                               uint16_t statsPeriod)
 {
     if (!dcmi::isDCMIPowerMgmtSupported())
@@ -389,15 +631,61 @@ ipmi::RspType<> setPowerLimit(ipmi::Context::ptr& ctx, uint16_t reserved1,
         return ipmi::responseInvalidCommand();
     }
 
-    // Only process the power limit requested in watts. Return errors
-    // for other fields that are set
-    if (reserved1 || reserved2 || correctionTime || statsPeriod ||
-        exceptionAction != exceptionPowerOff)
+    if (!dcmi::setPcap(ctx, powerLimit))
     {
-        return ipmi::responseInvalidFieldRequest();
+        return ipmi::responseUnspecifiedError();
     }
 
-    if (!dcmi::setPcap(ctx, powerLimit))
+    /*
+     * As defined in table 6-18 of DCMI specification version 1.5.
+     * The Exception action value is mapped as below
+     *  00h - No Action
+     *  01h - Hard Power Off system and log events to SEL
+     *  02h - 10h OEM defined actions
+     *  11h - Log event to SEL only
+     *  12h-FFh Reserved
+     */
+    PcapClass::ExceptionActions exceptAct{};
+    if (exceptionAction >= 0x12)
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    switch (exceptionAction)
+    {
+        case 0x00:
+        {
+            exceptAct = PcapClass::ExceptionActions::NoAction;
+            break;
+        }
+        case 0x01:
+        {
+            exceptAct = PcapClass::ExceptionActions::HardPowerOff;
+            break;
+        }
+        case 0x11:
+        {
+            exceptAct = PcapClass::ExceptionActions::LogEventOnly;
+            break;
+        }
+        default:
+        {
+            exceptAct = PcapClass::ExceptionActions::Oem;
+            break;
+        }
+    }
+
+    if (!dcmi::setPcapExceptAction(ctx, exceptAct))
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    if (!dcmi::setPcapCorrectTime(ctx, correctionTime))
+    {
+        return ipmi::responseUnspecifiedError();
+    }
+
+    if (!dcmi::setPcapSamplPeriod(ctx, statsPeriod))
     {
         return ipmi::responseUnspecifiedError();
     }
-- 
2.34.1

