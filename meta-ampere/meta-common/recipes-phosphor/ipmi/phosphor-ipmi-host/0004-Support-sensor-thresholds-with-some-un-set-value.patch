From 004ef509210d0ed8f420d5e29ace24c032c5abc5 Mon Sep 17 00:00:00 2001
From: Hieu Huynh <hieuh@os.amperecomputing.com>
Date: Fri, 24 Jun 2022 10:16:33 +0000
Subject: [PATCH 4/7] Support sensor thresholds with some un-set value

For the sensors that does not support the threshold values such as
WarningLow, WarningHigh, CriticalLow, CriticalHigh. As defined by SDR
definition, these values should be 'na'.

Signed-off-by: Hieu Huynh <hieuh@os.amperecomputing.com>
---
 sensorhandler.cpp | 67 +++++++++++++++++++++++++++--------------------
 1 file changed, 38 insertions(+), 29 deletions(-)

diff --git a/sensorhandler.cpp b/sensorhandler.cpp
index d58a2d4..63b6d1d 100644
--- a/sensorhandler.cpp
+++ b/sensorhandler.cpp
@@ -688,14 +688,19 @@ get_sdr::GetSensorThresholdsResponse
     }
 
     ipmi::PropertyMap warnThresholds;
-    ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
+    try
+    {
+        ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
                                     warningThreshIntf, warnThresholds);
-    if (!ec)
+    }
+    catch(const std::exception& e)
     {
-        double warnLow = std::visit(ipmi::VariantToDoubleVisitor(),
-                                    warnThresholds["WarningLow"]);
-        double warnHigh = std::visit(ipmi::VariantToDoubleVisitor(),
-                                     warnThresholds["WarningHigh"]);
+        // No warning thresholds
+    }
+    double warnLow = ipmi::mappedVariant<double>(warnThresholds,
+            "WarningLow", std::numeric_limits<double>::quiet_NaN());
+    double warnHigh = ipmi::mappedVariant<double>(warnThresholds,
+            "WarningHigh", std::numeric_limits<double>::quiet_NaN());
 
         if (std::isfinite(warnLow))
         {
@@ -714,35 +719,39 @@ get_sdr::GetSensorThresholdsResponse
             resp.validMask |= static_cast<uint8_t>(
                 ipmi::sensor::ThresholdMask::NON_CRITICAL_HIGH_MASK);
         }
-    }
 
     ipmi::PropertyMap critThresholds;
-    ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
+    try
+    {
+        ec = ipmi::getAllDbusProperties(ctx, service, info.sensorPath,
                                     criticalThreshIntf, critThresholds);
-    if (!ec)
+    }
+    catch(const std::exception& e)
     {
-        double critLow = std::visit(ipmi::VariantToDoubleVisitor(),
-                                    critThresholds["CriticalLow"]);
-        double critHigh = std::visit(ipmi::VariantToDoubleVisitor(),
-                                     critThresholds["CriticalHigh"]);
+        // No critical thresholds
+    }
 
-        if (std::isfinite(critLow))
-        {
-            critLow *= std::pow(10, info.scale - info.exponentR);
-            resp.lowerCritical = static_cast<uint8_t>(
-                round((critLow - info.scaledOffset) / info.coefficientM));
-            resp.validMask |= static_cast<uint8_t>(
-                ipmi::sensor::ThresholdMask::CRITICAL_LOW_MASK);
-        }
+    double critLow = ipmi::mappedVariant<double>(critThresholds,
+            "CriticalLow", std::numeric_limits<double>::quiet_NaN());
+    double critHigh = ipmi::mappedVariant<double>(critThresholds,
+            "CriticalHigh", std::numeric_limits<double>::quiet_NaN());
 
-        if (std::isfinite(critHigh))
-        {
-            critHigh *= std::pow(10, info.scale - info.exponentR);
-            resp.upperCritical = static_cast<uint8_t>(
-                round((critHigh - info.scaledOffset) / info.coefficientM));
-            resp.validMask |= static_cast<uint8_t>(
-                ipmi::sensor::ThresholdMask::CRITICAL_HIGH_MASK);
-        }
+    if (std::isfinite(critLow))
+    {
+        critLow *= std::pow(10, info.scale - info.exponentR);
+        resp.lowerCritical = static_cast<uint8_t>(
+            round((critLow - info.scaledOffset) / info.coefficientM));
+        resp.validMask |= static_cast<uint8_t>(
+            ipmi::sensor::ThresholdMask::CRITICAL_LOW_MASK);
+    }
+
+    if (std::isfinite(critHigh))
+    {
+        critHigh *= std::pow(10, info.scale - info.exponentR);
+        resp.upperCritical = static_cast<uint8_t>(
+            round((critHigh - info.scaledOffset) / info.coefficientM));
+        resp.validMask |= static_cast<uint8_t>(
+            ipmi::sensor::ThresholdMask::CRITICAL_HIGH_MASK);
     }
 
     return resp;
-- 
2.25.1

