From 41d72ad6bc5183d95ff016deb07ab9e7a3e950c5 Mon Sep 17 00:00:00 2001
From: Dung Cao <dung@os.amperecomputing.com>
Date: Tue, 15 Nov 2022 20:48:50 +0700
Subject: [PATCH] pldmtool: fix pldmtool stuck in waiting forever response

Sometime one request may not receive the response. pldmtool should not
stuck in waiting forever the response. It should have a timeout
waiting for the response and retry to send the request before issuing
new pldm request.

Signed-off-by: Dung Cao <dung@os.amperecomputing.com>
Change-Id: I70b62b1ff30a8a715716db43867b479a5b214dfa
---
 src/requester/pldm.c | 37 +++++++++++++++++++++++++------------
 1 file changed, 25 insertions(+), 12 deletions(-)

diff --git a/src/requester/pldm.c b/src/requester/pldm.c
index 34f0c30..bb04e5e 100644
--- a/src/requester/pldm.c
+++ b/src/requester/pldm.c
@@ -6,9 +6,12 @@
 #include <string.h>
 #include <sys/socket.h>
 #include <sys/un.h>
+#include <time.h>
 #include <unistd.h>
 
 const uint8_t MCTP_MSG_TYPE_PLDM = 1;
+const int NUMBER_OF_REQUEST_RETRIES = 2;
+const int RESPONSE_TIME_OUT = 1000;
 
 pldm_requester_rc_t pldm_open()
 {
@@ -144,22 +147,32 @@ pldm_requester_rc_t pldm_send_recv(mctp_eid_t eid, int mctp_fd,
 {
 	struct pldm_msg_hdr *hdr = (struct pldm_msg_hdr *)pldm_req_msg;
 	if ((hdr->request != PLDM_REQUEST) &&
-	    (hdr->request != PLDM_ASYNC_REQUEST_NOTIFY)) {
+		(hdr->request != PLDM_ASYNC_REQUEST_NOTIFY)) {
 		return PLDM_REQUESTER_NOT_REQ_MSG;
 	}
 
-	pldm_requester_rc_t rc =
-	    pldm_send(eid, mctp_fd, pldm_req_msg, req_msg_len);
-	if (rc != PLDM_REQUESTER_SUCCESS) {
-		return rc;
-	}
-
-	while (1) {
-		rc = pldm_recv(eid, mctp_fd, hdr->instance_id, pldm_resp_msg,
-			       resp_msg_len);
-		if (rc == PLDM_REQUESTER_SUCCESS) {
-			break;
+	int i = 0;
+	pldm_requester_rc_t rc;
+	time_t t;
+	int sec;
+	while (i < (NUMBER_OF_REQUEST_RETRIES + 1)) {
+		rc = pldm_send(eid, mctp_fd, pldm_req_msg, req_msg_len);
+		if (rc != PLDM_REQUESTER_SUCCESS) {
+			return rc;
+		}
+		t = time(NULL);
+		while (1) {
+			rc = pldm_recv(eid, mctp_fd, hdr->instance_id,
+				       pldm_resp_msg, resp_msg_len);
+			if (rc == PLDM_REQUESTER_SUCCESS) {
+				return rc;
+			}
+			sec = (int)(time(NULL) - t);
+			if (sec >= (RESPONSE_TIME_OUT / 1000)) {
+				break;
+			}
 		}
+		i++;
 	}
 
 	return rc;
-- 
2.17.1

